# Leetcode刷题笔记

[toc]

## 2021年12月

### 20211206，除自身以外数组的乘积

[leetcode链接](https://leetcode-cn.com/problems/product-of-array-except-self/)

*关键词* : 双向遍历

做过的题目，从两头各遍历一次，第一次做很难做出来，做过一次后再遇到就容易想到了。

### 20211207，搜索二维矩阵

[leetcode链接](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

*关键词* ：二维数组

也是做过的题，第一次做的时候理解还不深刻，没有意识到自己的解法的问题所在。自己的做法是根据中心点与目标值大小的比较把整个矩阵分成4块，然后可以根据比较结果丢掉一块，分别对剩余三块进行递归，以为这样时间复杂度就是O(log(mn))，实际上不是，见下图：

```text
                                               n
                                                    
                                                    
             n/4                              n/4                               n/4
                  
                                                                                                  log4(mn)层
                  
n/16         n/16        n/16    n/16          n/16         n/16      n/16        n/16      n/16
     
     
     ..................................................................................................
```

最底层总共有3^log4(mn)^ =(mn)^log4(3)^ 个元素，因此根据等比数列求和公式，总的时间复杂度还是O((mn)^log4(3)^)，很接近O(mn)，并不是想的O(log(mn))。而答案的做法则是很巧妙地从右上角开始，每进行一次比较就丢弃掉一行或者一列，时间复杂度达到O(m+n)，代码也很简洁。

### 20211208，完全平方数

[leetcode链接](https://leetcode-cn.com/problems/perfect-squares/)

*关键词* ：动态规划，数学题

动态规划题，一开始还是用的有记忆的递归做的，理论上时间复杂度应该是一样的，但是实际上递归会慢很多，以后遇到这种题就不需要犹豫，直接动态规划就好了。另外答案还给了数学方法的解法，大大降低时间复杂度。但是用到的数学原理实在是太专业了，非数学相关专业一般接触不到的做法，所以也挺无聊的。

### 20211209，寻找重复数

[leetcode链接](https://leetcode-cn.com/problems/find-the-duplicate-number/)

*关键词* ：二分法，位运算，Floyd判圈算法

要满足空间复杂度为O(1)，难度挺大的题。如果时间复杂度为O(nlog(n))，可以采用二分法与位运算的做法，进一步将时间复杂度提高到O(n)，就只有采用Floyd判圈算法。这三种做法思路都非常巧妙，下面分别进行分析。

1. 二分法

    根据数组中比`i`小的元素数量`count[i]`的大小与`i`的大小关系来判断`i`是比要找的数大还是小，从而把`[1, n]`分成两半，对目标所在的一半继续进行递归操作，直到找到目标值。有个细节需要注意，就是用来存储结果的变量`result`的更新的问题，由于`result`肯定是在`count[i] > i`的部分，因此只有进入到这一部分时，才需要将`result`更新为当前的`middle`变量的值，进入另一部分时只需要更新范围，不需要更新结果变量。

2. 位运算

    自己做的时候想过位运算方向的解法，可惜没想明白。这种做法是逐位求出目标值，巧妙点在于对每一位，对比数组`nums`中该位置为`1`的元素的数量，将其与数组`[1, n]`中该位置为`1`的元素数量对比，若前者大，则说明目标值该位置为`1`，否则为`0`，利用这个原理，就能很容易地做出这题。

3. Floyd判圈算法

    最快的做法，时间复杂度达到了O(n)，但我感觉也是没看过答案绝对做不出的方法。这种做法把数组看作一个有向图的`n + 1`条边，分别表示由`i`指向`nums[i]`，`n + 1`个节点共有`n + 1`条边，而且必有一个节点入度为`2`以上，因此该有向图必存在一个圈，且入圈的节点就是入度为`2`的节点，也就是我们要找的重复数，这个问题就变成了寻找环形链表的入环节点的问题，就可以用时间复杂度为O(n)的Floyd判圈算法解决该问题。

### 20211210，最长递增子序列

[leetcode链接](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

*关键词* ：二分法，动态规划，改进动态规划

O(n^2^)时间复杂度的解法不难实现，普通的动态规划就可以，而O(nlog(n))时间复杂度的解法就很困难了。前者选取的状态变量为以元素`nums[i]`结尾的最长递增子序列，而后者则完全换了方法，选取长度为`l`的最长递增子序列的结尾元素作为状态变量，并在遍历的过程中对状态变量数组进行更新，这种情况下的状态变量数组是有序的，因此就可以采用二分查找，把时间复杂度降下来。这种题至少需要大量的积累才有可能能有最优解法的思路，还需努力。

### 20211211，最佳买卖股票时机含冷冻期

[leetcode链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

*关键词* ：动态规划，空间优化动态规划

比较难的动态规划问题。选取的状态变量是能比较容易想到的第`i`天结束后的最大收益，不过困难的是这个状态变量又分成了三种情况，分别是第`i`天结束后持有股票，未持有股票并处于冷冻期和未持有股票而且不处于冷冻期，根据第`i - 1`天这三种情况下的状态就可以推出第`i`天的状态。最后只需要求出最后一天两种不持有股票情况下的最大值就可以得出答案。综合来看状态变量的选取以及转移方程都比较难想，还需要更多积累才能做好这道题。

### 20211212，零钱兑换

[leetcode链接](https://leetcode-cn.com/problems/coin-change/)

*关键词* ：动态规划

基本上是最基础的不能进行空间优化的动态规划了，和前几天做的[完全平方数的题](##20211208，完全平方数)的动态规划解法差不多。

### 20211213，打家劫舍III

[leetcode链接](https://leetcode-cn.com/problems/house-robber-iii/)

*关键词* ：记忆递归，动态规划，空间优化动态规划，深度优先搜索(DFS)

把动态规划搬到了二叉树结构，与普通动态规划区别只是在于将普通数组换成了哈希表。由于对二叉树的深度优先遍历本身就要用到递归栈，因此本题用带记忆的递归也可以做，本质上是一样的，就是动态规划是后序遍历，而记忆递归某种程度上算是先序遍历。不过动态规划可以进行空间优化，由于对于每个节点的分析只需要用到它的两个子节点的结果，因此可以去掉哈希表。

### 20211214，前K个高频元素

[leetcode链接](https://leetcode-cn.com/problems/top-k-frequent-elements/)

*关键词* ：堆，快速排序

可以用大根堆做，也可以用小根堆做，大根堆就是把所有元素放进堆中，然后取出前K个放进数组，这种情况下的时间复杂度是O(nlog(n))，而小根堆则是将容量限制为K，维护前K个出现频率最高的元素，这种情况下的时间复杂度是O(nlog(k))，所以理论上来说小根堆更好一些。另一种做法是利用快排的原理，每次确定一个元素的位置，直到确定的元素位置恰好为K时，即可确定前K个高频元素，这种解法理论上的时间复杂度可以降低到O(n)。

### 20211215，字符串解码

[leetcode链接](https://leetcode-cn.com/problems/decode-string/)

*关键词* ：栈，递归

辅助栈的做法和递归的做法差不多。这种题说难也不难，但是麻烦是真麻烦，要把代码写得简洁更麻烦，不知道笔试面试喜欢不喜欢考这种题。

### 20211216，除法求值（待解决）

[leetcode链接](https://leetcode-cn.com/problems/evaluate-division/)

*关键词* ：加权并查集

很难啊，先留一留，后面慢慢看。

### 20211217，根据身高重建队列

[leetcode链接](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

*关键词* ：排序

想法不算很难的一道题。有个细节需要注意，就是排序的时候可以优先通过身高排序，然后根据第二项也就是身前有多少人进行逆序排序，这样就可以避免另外处理身高相同的情况，这个想法很值得学习。另外让我不太明白的一点在于从低到高排序然后通过数`null`来插入数组的做法为什么会比从高到低排序然后插入列表然后转化为数组的做法慢这么多，能想到的可能的原因在于第一种方法耗费的时间大约是n^2^，而第二种方法耗费的时间大约是n^2^/2，或者还是说Java的ArrayList的插入有优化？不理解。

### 20211218，分割等和子集

[leetcode链接](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

*关键词* ：动态规划，空间优化动态规划，高时间复杂度，背包问题

挺难的题，主要在于这种动态规划方法不好想，无论是状态变量还是转移方程，而且这道题的时间复杂度还很高，显得更吓人了。而且答案中从普通动态规划转向空间优化的动态规划过程中有一些细节需要注意。

### 20211219，路径总和III

[leetcode链接](https://leetcode-cn.com/problems/path-sum-iii/)

*关键词* ：深度优先搜索(DFS)，空间换时间，前缀和

也不算简单的题，暴力一点是要分别从每个节点开始向下搜索，时间复杂度为O(n^2^)，而这道题的解法则很巧妙地用了前缀和的做法，这样就可以利用空间换时间的思想，建立一个哈希表，把内部循环改成时间复杂度为常数的哈希表查询，从而将时间复杂度降为O(n)。前缀和的采用是本题的关键。

### 20211220，找到字符串中所有字母异位词

[leetcode链接](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

*关键词* ：滑动窗口

普通的滑动窗口的方法很容易想到，但是时间复杂度较高，本题答案的关键步骤就在于对检测字母异位词的过程的优化，采用一个记录当前字符串与目标字符串不同数目的字母的个数的变量以及一个记录各字母数目差别的数组，每次移动窗口只需要访问两个位置来维护这个变量，把时间复杂度降了下来。类似的时间复杂度降低的需求还是挺多的，不过解决方法似乎不尽相同。

### 20211221，目标和

[leetcode链接](https://leetcode-cn.com/problems/target-sum/)

*关键词* ：动态规划，空间优化动态规划，高时间复杂度，背包问题

和前几天的[那道题](##20211218，分割等和子集)差不多的题，都属于背包问题，解决方法也类似，唯一的区别在于那道题是找没有，而这道题是找有多少种。有个细节需要注意，以空间优化前的做法为例，需要建立一行辅助行，用于表示有0个元素可选时能组成各数的选法数目，前几天的题没有这一行是没关系的，可以通过对第一行多做一些处理来等效，但是今天这道题在`[0, 0, 0, 0, 0, 1]`这类输入时就会出现问题。

### 20211222，把二叉搜索树转换为累加树

[leetcode链接](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

*关键词* ：深度优先搜素(DFS)，Morris遍历

普通的中序遍历做法很容易，不过空间复杂度较高，递归占的空间为O(n)。比较有趣的做法是Morris遍历做法，这种方法把空间复杂度降到了O(1)，但是其消耗的时间稍微长一点，但是渐进复杂度还是O(n)，答案复杂度分析好像有点问题，好像应该是没有右子树的节点会访问一次，而有右子树的节点会访问两次。这种做法很巧妙，类似于利用二叉树的叶子节点的闲置指针把二叉树展开为中序遍历的顺序的链表，而且时间复杂度还是与节点个数成正比的线性复杂度，很值得多思考的方法，以后遇到二叉树的问题也可以多尝试这种方法。

### 20211223，和为K的子数组

[leetcode链接](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

*关键词* ：前缀和

和前几天的[那道题](##20211219，路径总和III)差不多的做法，那道题是在树上应用了前缀和的做法，而这道题是在数组上应用前缀和的做法，这道题还相对简单一点。从这两道题可以总结出的经验是前缀和的做法基本都应用于**连续**的和，可以把时间复杂度从其他做法的O(n^2^)降到O(n)，不过要额外占用O(n)的空间复杂度。

### 20211224，最短无序连续子数组

[leetcode链接](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

*关键词* ：排序，逆序对

从逆序对的角度来考虑好理解一点。要把数组分成三部分，只要把中间部分排序那么整个数组就是有序的，所以所有的逆序对都必须落在中间部分，要找中间部分的边界，就要找所有逆序对中最左边的边界与最右边的边界。以寻找右边界为例分析一下，自己的做法是新建一个数组，首先从左到右遍历，记录每个位置之前的最大值，得到一个最大值数组，然后从右往左遍历，对比原数组与最大值数组的不同，第一个不同的位置就说明这个位置之前有个比他更大的元素，说明这个就是所有逆序对的右边界；而答案的做法则是在从左向右遍历的同时用一个变量记录到目前为止的最大值，并用一个变量来维护右边界的位置，当遍历到的位置比最大值小时，说明这个位置是某个逆序对的右边，遍历一遍后就能找到所有逆序对最右边的边界。自己的做法需要遍历两次，而且需要一个额外的数组存放最大值，而答案的方法只需要遍历一次，而且只需要常数级的空间，所以显然答案的方法更优。

### 20211225，任务调度器

[leetcode链接](https://leetcode-cn.com/problems/task-scheduler/)

*关键词* ：数学题

不好说这是什么解法，自己想的时候太执着于排序之后再做了，而且没考虑明白字母种类比n大的情况，也是考虑思路错了。按答案写的解法不算太快，比较快的解法是用长为26的数组代替哈希表，这一点值得注意。

### 20211226，回文子串

[leetcode链接](https://leetcode-cn.com/problems/task-scheduler/)

*关键词* ：Manacher算法

一开始看到这题就想用动态规划做，倒是也能做，但是时间复杂度高达O(n^2^)，空间复杂度也有O(n)，都算不上好。答案给出的第一种遍历所有回文子串的可能的中心，然后向两边扩展的方法时间复杂度也是O(n^2^)，而且只使用了常数的空间。关于这个解法需要注意的奇数长度回文串与偶数长度回文串的结合方法，通过遍历包括字母位置与字母之间的位置共`2n-1`个中心，把两种情况合到一个循环里。而答案的第二种做法，也就是Manacher算法，把时间复杂度压到了O(n)。这种算法通过在从左向右遍历的过程中记录一个到目前为止的回文子串所能到达的最右边的位置，结合前面已经计算过的与以这个最右边位置对应的回文子串中心对称的点的回文子串的长度，避免一定的重复计算。不过现在确实对这个算法理解不够深刻，还要多回来复习复习。

### 20211227，每日温度

[leetcode链接](https://leetcode-cn.com/problems/daily-temperatures/)

*关键词* ：单调栈

自己的做法算是动态规划从右向左遍历温度数组，对于遍历到的元素，通过其右边的元素的状态来确定其状态，若右边元素比该元素大，则待求位置的结果就是1，否则，再判断右边位置的天数是不是0，如果是的话那么可以直接给当前位置赋0，否则就找到右边位置的结果对应的位置，重复上述过程。这种做法比较宽松的一个时间复杂度上限是O(n^2^)，但是暂时还不知道准确的时间复杂度该是多少。答案用的单调栈的方法，时间复杂度为O(n)，是很合理的做法，但是什么情况下要用单调栈的做法还需要多归纳。

### 20211228，两数相加

[leetcode链接](https://leetcode-cn.com/problems/add-two-numbers/)

*关键词* ：链表

挺普通的题。个人感觉这题最大的意义在于锻炼提高代码简洁度的水平。

### 20211229，无重复字符的最长字串

[leetcode链接](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

*关键词* ：滑动窗口

自己想的办法实际上跟答案差不多，都可以用滑动窗口来理解。就是自己的方法一开始用了一个队列比较多余，可以直接双指针解决的。可以优化的点在于用128位的数组代替哈希表。

### 20211230，全排列

[leetcode链接](https://leetcode-cn.com/problems/permutations/)

*关键词* ：回溯

普通的DFS回溯算法，答案做法相比于自己的做法优化了空间复杂度，通过在原数组直接修改避免了用一个额外的标记数组或者用个链表来标记遍历过的数组元素。

### 20211231，两数之和

[leetcode链接](https://leetcode-cn.com/problems/two-sum/)

*关键词* ：哈希

普通的哈希表的应用。

## 2022年1月

### 20220101，有效的括号

[leetcode链接](https://leetcode-cn.com/problems/valid-parentheses/)

*关键词* ：辅助栈

辅助栈的简单应用。

### 20220102，合并两个有序链表

[leetcode链接](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

*关键词* ：无

简单得不知道怎么说。

### 20220103，最大子数组和

[leetcode链接](https://leetcode-cn.com/problems/maximum-subarray/)

*关键词* ：前缀和，动态规划

自己做的时候是用的前缀和的做法，答案用的是动态规划的做法，复杂度上来说都是一样的，不过动态规划确实直接一点，不过转移方程可能会有一点点不好想。从之前做过的题来看，前缀和的做法主要应用于求连续子数组/子路径等的个数，在这里不是完全适用，不过原理也算相通。这里用的是很简单的版本，只是记录着到目前为止遍历到的最小的前缀和。

### 20220104，爬楼梯

[leetcode链接](https://leetcode-cn.com/problems/climbing-stairs/)

*关键词* ：动态规划，快速幂

基础的动态规划题目，由于是线性递推公式，所以也可以用矩阵快速幂解决，把时间复杂度降到O(log(n))。矩阵快速幂是一种之前没有了解过的方法，这种思想很值得学习。

### 20220105，对称二叉树

[leetcode链接](https://leetcode-cn.com/problems/symmetric-tree/)

*关键词* ：递归

有递归和迭代两种做法，递归显而易见，没什么需要说的。至于迭代，可以广度优先迭代也可以深度优先迭代，建立一个队列或者一个栈，每次进队出队或者进栈出栈一对元素，实际上也很容易理解。

### 20220106，二叉树的中序遍历

[leetcode链接](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

*关键词* ：中序遍历，Morris遍历

基本的中序遍历，有递归、迭代和Morris遍历三种做法。递归不用说；迭代的做法用来实现先序遍历比较容易，但是也可以用来实现中序遍历，不过操作比较麻烦，以后要多熟悉一下；Morris遍历在之前写过一次，其实也不是很难，多熟悉熟悉思路应该不会被难住。

### 20220107，二叉树的最大深度

[leetcode链接](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

*关键词* ：BFS

可以递归，也可以宽度优先搜索，看上去递归更快一点。注意，是递归，不是DFS。

### 20220108，买卖股票的最佳时机

[leetcode链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

*关键词* ：无

买卖股票系列最简单的题，不过不同于同系列其他题需要用到二维动态规划，本题只需要记录最小值，不具有太大参考价值。

### 20220109，只出现一次的数字

[leetcode链接](https://leetcode-cn.com/problems/single-number/)

*关键词* ：位运算

利用相同的数字按位异或后结果为0的特点，将整个数组逐个进行异或运算，得到的结果就是唯一的只有一个的数字。位运算的意识和对这种异或特性的敏感性是做这道题的关键点，不常用位运算而且是第一次做这题的话几乎不可能会，但是做过一次之后也就不难想到了。

### 20220110，环形链表

[leetcode链接](https://leetcode-cn.com/problems/linked-list-cycle/)

*关键词* ：快慢指针，Floyd判圈算法

基础的Floyd判圈算法应用，但是还没有让求进环节点。

### 20220111，最小栈

[leetcode链接](https://leetcode-cn.com/problems/min-stack/)

*关键词* ：无

用一个辅助栈保存到目前为止的最小值，比较容易的思路。

### 20220112，相交链表

[leetcode链接](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

*关键词* ：无

两个指针分别从各自头节点出发，走完当前链表再去走另一个链表，直到两个指针相等，即指向相交节点或者都为`null`，也是属于没做过很难想到，但是做过一遍就完全没难度的题。

### 20220113，多数元素

[leetcode链接](https://leetcode-cn.com/problems/majority-element/)

*关键词* ：摩尔投票法

摩尔投票法概念的引出，如果熟悉这个思想的话这题并不难。

### 20220114，反转链表

[leetcode链接](https://leetcode-cn.com/problems/reverse-linked-list/)

*关键词* ：双指针

双指针同时前进，遍历一遍即可。需要注意的是可以将给出的`head`头指针为`null`的情况与其他情况合在一起。

### 20220115，翻转二叉树

[leetcode链接](https://leetcode-cn.com/problems/invert-binary-tree/)

*关键词* ：无

基础递归。

### 20220116，回文链表

[leetcode链接](https://leetcode-cn.com/problems/palindrome-linked-list/)

*关键词* ：无

不太好想的一个思路，判断链表的回文是通过先找到中间点，在切下右半部分，然后利用[反转链表](##20220114，反转链表)的方法将右半部分反转，再与左半部分比较，实现并不难，也没有什么特别刁钻的方法，不过第一遍做要想到这种做法还是要花点时间的。

### 20220117，移动零

[leetcode链接](https://leetcode-cn.com/problems/move-zeroes/)

*关键词* ：双指针

一种自己想的方法是遍历一遍，记录数组中所有0的位置，然后再遍历一遍，根据已知的0的位置移动元素，这样要遍历两遍，而且空间复杂度为O(n)，而双指针的做法可以只遍历一遍，而且空间复杂度为O(1)。另一个值得学习的点在于答案中双指针部分外层大遍历和内层小遍历的结合方式，一种比较优雅的写法。

### 20220118，比特位计数

[leetcode链接](https://leetcode-cn.com/problems/counting-bits/)

*关键词* ：位运算，Brian Kernighan 算法

动态规划+位运算的方法。很明显的动态规划题目，位运算部分比较有意思。基础的把当前元素除2并结合奇偶判断不算太难想。其他方法都用到了Brian Kernighan 算法，其思想是`i & (i - 1)`这个表达式可以消掉二进制形式的`i`的最后一个`1`，这个思想很关键，引申出很多计算当前元素二进制去掉一个`1`的方法，而且感觉也可以在其他很多位运算的题目中应用，需要多多注意。

### 20220119，找到所有数组中消失的数字

[leetcode链接](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

*关键词* ：无

要在不使用哈希表和同样效果的标记数组的情况下，就要利用原数组中每个元素都在`1`和`n`之间的性质，改变原数组，把原数组当作哈希表用。自己的做法是把遍历到的元素对应数组位置改成`-1`，再把那个位置的元素移动到当前位置，再次进行判断，直到当前位置为`-1`。这种做法可行，但是比较麻烦。答案用的做法是遍历到的元素对应数组位置加`n`，从而后面遍历的时候可以通过取余来取出数组元素，这样可以在保留原数组全部信息的同时达到标记的目的。在不需要考虑整数溢出的情况下是很好的方法。

### 20220120，汉明距离

[leetcode链接](https://leetcode-cn.com/problems/hamming-distance/)

*关键词* ：位运算，Brian Kernighan 算法

又用到了Brian Kernighan 算法，这种算法虽然不足以降低时间复杂度，但是可以避免很多不必要的运算。

### 20220121，二叉树的直径

[leetcode链接](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

*关键词* ：DFS，后序遍历

通过后序遍历计算以每个节点为中心的两个树枝的最大深度，加起来得到该节点的最大直径。遍历过程中需要记录的包括节点深度以及目前遍历到的最大直径。自己的做法是把直径当作递归函数返回值，然后用一个哈希表记录各节点深度，而答案是把直径放到全局变量，把深度当作递归函数返回值，这样做节省了哈希表的空间，但是需要一个全局变量。尝试了一下用迭代的方式避免全局变量的使用，好像不太容易。

### 20220122，合并二叉树

[leetcode链接](https://leetcode-cn.com/problems/merge-two-binary-trees/)

*关键词* ：DFS

递归深度优先遍历即可很容易地解决。广度优先遍历原理也不是太难，但是代码更复杂，有点多此一举的感觉。

### 20220123，合并K个升序链表

[leetcode链接](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

*关键词* ：堆

很简单的一道困难题。思路有两个，一个是每次处理一半，然后将结果合并，递归此操作；另一个是引入一个堆，每次取出堆顶上的一个元素加入结果链表。两种做法的时间复杂度都是O(n*log(k))，其中`n`是所有链表的节点总个数，`k`是链表个数。

### 20220124，最长有效括号

[leetcode链接](https://leetcode-cn.com/problems/longest-valid-parentheses/)

*关键词* ：动态规划，栈

三种做法，都说不上太难理解。其中动态规划的做法比较容易想到，借助辅助栈的做法和用两个变量分别计数左括号和右括号的做法都是利用了从某个右括号开始计数，每次达到左右括号数量相等的时候就计算一下此时的有效序列长度，当右括号更多的时候就重新开始计数。其中用两个变量分别计数的方法需要考虑左括号一直比右括号多的情况，解决方法是再反向遍历一遍。这种做法的空间复杂度是O(1)，是最佳的做法。

### 20220125，接雨水

[leetcode链接](https://leetcode-cn.com/problems/trapping-rain-water/)

*关键词* ：单调栈，双指针

三种做法。最近的困难题都死这种，有几个比较容易想到的做法，但时间空间复杂度都不是最优，最佳方法需要花一些功夫。在这个题里面，正反两次遍历，并用一个额外的数组存储一个方向的遍历结果的解法比较容易想到，但是空间复杂度为O(n)，而且要遍历两次；单调栈的做法是保存从栈底到栈顶递减的栈，遍历到一个比栈顶元素高的柱子时，就弹出栈顶元素，并计算由当前元素，弹出的元素以及弹出之后的栈顶元素构成的洼地的体积，加到结果里面，这种做法只要遍历一次，但是栈要占用额外的O(n)的空间复杂度；最佳的双指针做法理解起来有点困难，能想到就更困难了，这个题的核心思想在于每个列能容纳的雨水由其左边的最高的柱子和其右边的最高的柱子决定，两次遍历的做法就是分别求这两个值，而双指针的做法则巧妙地只用一个边界计算每一列的水，实现这种情况的前提就是用来确定高度的边界一定是比较小的那个边界，本解法用双指针实现了这个前提，不同于朝一个方向的顺序遍历，双指针解法利用两个指针进行由两侧向中间的遍历，实现所用的边界是较小的边界的关键就在于，每次都处理并移动当前高度较小的指针，这样做就确保了处理某一侧的时候，另一侧一定存在遍历到的某个柱子比本侧所有柱子都高，否则，假如本侧有更高的柱子的话，那么就不会处理并移动本侧的指针了，出现矛盾，因此这种做法是正确的。特别需要注意与学习双指针的做法。

### 20220126，正则表达式匹配

[leetcode链接](https://leetcode-cn.com/problems/regular-expression-matching/)

*关键词* ：动态规划

一开始没想到能用动态规划做，而且一直很自然地在想时间复杂度O(m+n)的做法，也就是同时遍历两个字符串，挨个匹配，但是真正写起来十分复杂，问题很多。相比之下动态规划的做法就聪明很多，但是时间与空间复杂度也上升到了O(mn)，不知道有没有人能写出O(m+n)的解法。动态规划的状态变量选为字符串`s`的前`i`个元素与字符串`p`的前`j`个元素能否匹配，这一点不容易想到，想到这一点之后，剩下的难点就在于遍历到字符串`p`的`*`时如何解决的问题，这实际上也是在写直接遍历匹配两个字符串时遇到的主要困难，这里动态规划的解决方法也是很巧妙，将重复`0`次与重复`n`次分开处理，重复`0`次就直接跳过，重复`n`次就把`s`字符串指针向前移一位对应的`dp`数组的结果取过来，这种做法更难想到，而且也不好理解，但是想到之后就能使代码变得非常简洁明了。

## 2022年2月

### 20220207，编辑距离

[leetcode链接](https://leetcode-cn.com/problems/edit-distance/)

*关键词* ：动态规划

困难难度的题好像很喜欢动态规划啊。这题确实是很难，选取word1的前i个字符和word2的前j个字符之间的编辑距离作为状态变量，这一点很难想到，递推则是用`dp[i][j-1]`、`dp[i-1][j]`和`dp[i-1][j-1]`三项来推出`dp[i][j]`的值。说起来也是普通的动态规划做法，但是自己做的时候面对着既能插入，又能删除，还能替换这么灵活的操作有点不知所措了，也不够大胆，没能分析出动态规划的做法。

### 20220208，最小覆盖子串

[leetcode链接](https://leetcode-cn.com/problems/minimum-window-substring/)

*关键词* ：滑动窗口，双指针

单纯的滑动窗口解法也不复杂，但是可能是因为自己滑动窗口的题目做的太少，没有想到怎么做。这里的窗口是一个变长的窗口，所以说与其叫滑动窗口，不如叫双指针。一开始做这道题的时候一直在想类似于之前[路径总和](##20211219，路径总和III)那道题的做法，也就是前缀和，不过在这里不太适用。滑动窗口做法的优化是另一个需要关注的点，这个做法中有很多地方需要比较当前某个子串是否包含目标字符串，如果用哈希表逐个字符对比的话，那么一次比较的时间复杂度就是O(C)，这里C是目标字符串中的字符种类数，但是优化做法可以用一个`count`变量来记录当前子串中对应目标字符串中各种字符的数目总和，其中数目超过目标字符串的则记目标字符串中该字符的数量，这样就可以用这一个变量来判断当前子串是否包含目标字符串，把这个过程的时间复杂度降到O(1)。

### 20220209，柱状图中的最大矩形

[leetcode链接](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

*关键词* ：单调栈

虽然没做出来，不过还是有那么一点成就感的。一开始想的动态规划和单调栈两种做法，排除了动态规划，单调栈的主要思路和答案一样，但是没有考虑到可以按每个位置的柱子高度作为矩形高度进行遍历，也就是没有想到时间复杂度为O(n^2^)的暴力做法，也就没办法用单调栈进行改进。单调栈的题目做得还是少，需要更多练习。另外一个需要注意的点在于新元素进栈时把栈中比新元素高度高的元素全部出栈，这一步对于高度相等的元素如何处理，其实不需要管，因为并不需要每个都准确求出，只需要求出最大值就好，不管怎么处理高度相等的柱子，都会有一个边界求出这个高度的最大矩形，这对于这道题来说也就够了。还有一个是数据结构的使用的问题，对于栈的实现数据结构，如果用`Stack`类的话执行时间约为`130ms`，同样的程序，换成`Deque`实现栈之后执行时间就只剩了`20ms`，虽然不知道为什么差距这么大，但是以后做题的时候如果要追求尽可能短的实际执行时间的话还是用`Deque`比较好。

### 20220210，最大矩形

[leetcode链接](https://leetcode-cn.com/problems/maximal-rectangle/)

*关键词* ：单调栈

这个是真的没想到能这么做，隐约记得好像之前做过这题，现在看来是记错了。一开始一直在想动态规划的做法，状态变量选为以每个位置为右下角的最大矩形，但是很难找到合适的递推关系。在想着简化暴力做法的时候也想到过先遍历一遍，求出每个位置以左/以上的连续`1`的个数，但是没有进一步和[柱状图中的最大矩形](##20220209，柱状图中的最大矩形)这题联系到一起，这一步最难想，但是如果能想通的话这题也就迎刃而解了，如果说有什么启发的话那就是尽可能把不会的题归类到之前用过的解法上，完全没见过的类型本身也很难做出来了。

### 20220211，二叉树中的最大路径和

[leetcode链接](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

*关键词* ：深度优先搜索(DFS)

很简单的一道困难题，顶多中等难度水平。需要讨论的一点是类成员变量的使用，在这里类成员变量相当于全局变量，在这道题中，辅助`DFS`方法需要同时记录两个变量，分别是到当前为止的最大路径和以及以当前节点为结尾的分支的最大和，但是方法只能有一个返回值，因此另一个值只能以类成员变量的形式存在，很多答案题解中并没有刻意避免成员变量的使用，所以以后如果遇到类似的方法需要两个返回值，而且引入成员变量后可以大幅简化的情况还是可以用的。

### 20220212，滑动窗口最大值

[leetcode链接](https://leetcode-cn.com/problems/sliding-window-maximum/)

*关键词* ：单调队列，分块预处理

从题解来看不是一道很难的题，而且还做过一遍，但是还是没想出来该怎么做。单调队列或者单调栈的思路总是和最值问题练习在一起，另外的分块预处理的做法是第一次见，很有意思，很新颖。总的来说通过这题还是要多反思为什么没有想到单调队列的做法，以及学习分块预处理的做法。

### 20220213，删除无效的括号

[leetcode链接](https://leetcode-cn.com/problems/remove-invalid-parentheses/)

*关键词* ：回溯

答案的做法比自己想的暴力得多，回溯的做法从思路上来说不算太困难，不过要考虑一下剪枝的策略。广度优先的做法就更不用说了，更暴力，不过也因为太暴力了不容易想到。从思路上来说称得上是困难的就是状态枚举子集的做法了，这种做法分别处理左括号与右括号，根据需要删除的总的左括号数与右括号数，枚举所有可能的删除可能，然后将左括号与右括号的删除结果进行组合，验证正确性，需要注意的是，在这个过程中，枚举的删除可能性是通过一个整数模拟的，对于该整数的各位，若为`1`，则该位置删除，否则不删除，从而可用`Integer`类的`bitcount(int i)`方法计数删除个数，初步筛选。

### 20220214，戳气球

[leetcode链接](https://leetcode-cn.com/problems/burst-balloons/)

*关键词* ：动态规划

这道题，暴力解法的时间复杂度是O(n!)，为了简化，不难想到可以借助动态规划的方法。动态规划的核心思想在于复用某部分的计算结果，但是在原来的戳气球的背景下，复用的方法难以想到。答案比较巧妙地从后往前处理，把戳气球的问题变成了挂气球的问题，这样就可以达到复用计算结果的目的。回过头来看，动态规划必然是从较为简单的情况开始处理，而在这道题中，一开始挂满气球的情况是最复杂的情况，而只剩一个气球的情况则是最简单的情况，因此把戳气球问题转化成挂气球问题也是顺理成章的问题。所以，以后遇到类似这种似是而非的动态规划的问题，有两件事需要思考，第一个是最简单的情况是怎样的，找到最简单的情况后就从这个位置开始处理；第二个是怎样才能复用计算结果，或者可以在脑内模拟一下暴力做法的计算过程，想一想哪些计算是重复的。听上去上面这些全是废话，好像这些都是动态规划所必备的，可能还是自己对动态规划的理解不够深刻，还需要多做题，多训练。

### 20220215，寻找两个正序数组的中位数

[leetcode链接](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

*关键词* ：二分查找

这道题主题思路也算是说难也不太难，但是非常麻烦，有非常多的细节需要考虑。第二种做法利用了一点数学公式的推导，思路比较新颖，需要多看一看。细节方面的东西感觉只能多做题多总结。

### 20220216，节点间通路

[leetcode链接](https://leetcode-cn.com/problems/route-between-nodes-lcci/)

*关键词* ：图，DFS，BFS

最最基础的图论题目，BFS和DFS都可以做。

### 20220217，二分查找

[leetcode链接](https://leetcode-cn.com/problems/binary-search/)

*关键词* ：二分查找

基础二分查找，关键在于区间边界是否包含(`right = nums.length` 或 `right = nums.length - 1`)，循环比较是否取等(`left < right` 或 `left <= right`)，以及移动右边界的位置(`right = middle` 或 `right = middle + 1`)这三个问题，实际只有两种情况，需要明确。

### 20220218，移除元素

[leetcode链接](https://leetcode-cn.com/problems/remove-element/)

*关键词* ：双指针

应该也是之前做过的题目，记得之前做的时候还想着计算每个元素该移动的长度，把问题想得过于复杂了，相对来说双指针做法很直观，后面专门练习双指针的时候可以再总结。这道题的优化双指针解法比较有意思，不过这么做的前提是题目对结果的元素顺序没有要求。

### 20220219，有序数组的平方

[leetcode链接](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

*关键词* ：双指针

题目不难，不过比较直观的是想找到中间的0点，并从0点开始向两边遍历，来从左向右填充平方数组，但是稍微拐一点弯就有一个更简单的方法，那就是从两边向中间遍历，从右向左填充平方数组，省掉了寻找0点的操作。

### 20220220，长度最小的子数组

[leetcode链接](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

*关键词* ：前缀和，滑动窗口

好像大家都能想到滑动窗口的做法，但是没想到前缀和的做法，但是在我这正好反过来，看到**连续**这两个字就想用前缀和的方法做，但是前缀和的做法边界问题需要花一定的精力去考虑，或者说是去试，而且滑动窗口的复杂度是绝对优于前缀和的，这么想想滑动窗口真是很神奇的做法，用两个指针遍历两遍就达到了暴力做法的效果，之前对这种做法思考较少，需要多留意，以后遇见**连续**关键词，尤其是数组中的连续，除了前缀和之外也要想想滑动窗口能不能发挥作用。

### 20220221，螺旋矩阵II

[leetcode链接](https://leetcode-cn.com/problems/spiral-matrix-ii/)

*关键词* ：无

就是模拟整个过程，需要考虑边界问题。

### 20220222，移除链表元素

[leetcode链接](https://leetcode-cn.com/problems/remove-linked-list-elements/)

*关键词* ：双指针

普通的链表双指针，注意虚拟头节点，也就是`sentinel`节点的运用，可以使代码更加优雅。

### 20220223，设计链表

[leetcode链接](https://leetcode-cn.com/problems/design-linked-list/)

*关键词* ：无

普通的设计类的题目，注意哨兵头节点的应用。

### 20220224，两两交换链表中的节点

[leetcode链接](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

*关键词* ：双指针

普通的链表双指针题目，同样注意哨兵节点的应用。

### 20220225，删除链表的倒数第N个节点

[leetcode链接](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

*关键词* ：双指针

普通双指针，还是要注意哨兵节点的使用，尤其是要删除的节点是头结点的时候。

### 20220226，链表相交

[leetcode链接](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

*关键词* ：双指针

这个第一次做的话能想到双指针非常不容易，但是做过一遍之后就没有什么难处了，还是要好好想一些小细节，不然会非常难受。

### 20220227，环形链表II

[leetcode链接](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

*关键词* ：快慢指针，Floyd判圈法

快慢指针做法，还是第一次做的话基本不可能做得出来，但是做过一两遍之后就容易了。哨兵节点仍然很好用，虽然答案没有用到，但是自己用起来还是能简化很多思考。

### 20220228，有效的字母异位词

[leetcode链接](https://leetcode-cn.com/problems/valid-anagram/)

*关键词* ：哈希表

基础的哈希思想。

## 2022年3月

### 20220301，两个数组的交集

[leetcode链接](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

*关键词* ：哈希表

这题有点刻意了，难度并不大。不过排序然后双指针的解法还是比较有意思的，值得学习。

### 20220302，快乐数

[leetcode链接](https://leetcode-cn.com/problems/happy-number/)

*关键词* ：哈希表，Floyd判圈法

哈希表的做法非常显而易见，但是还能用Floyd判圈法是没想到的，不过想想确实也是合理的，这样直接把空间复杂度降到了O(1)。Floyd判圈法的应用十分广泛，在涉及到环类问题的时候可以多往这方面考虑。

### 20220303，两数之和

[leetcode链接](https://leetcode-cn.com/problems/two-sum/)

*关键词* ：哈希表

哈希表的简单应用。需要注意的是答案的方法能一次遍历解决问题，没有必要先遍历一遍存个`Map`，再遍历一遍挨个寻找元素，一次遍历边存边找就能解决问题了。

### 20220304，四数相加II

[leetcode链接](https://leetcode-cn.com/problems/4sum-ii/)

*关键词* ：哈希表

把四个数组平分为两组，之后就和两数相加一样了。

### 20220305，赎金信

[leetcode链接](https://leetcode-cn.com/problems/4sum-ii/)

*关键词* ：哈希表

这也太简单了……

### 20220306，三数之和

[leetcode链接](https://leetcode-cn.com/problems/3sum/)

*关键词* ：双指针

先排序再利用双指针的做法，把时间复杂度阶数降低一级，空间复杂度只有排序的O(log n)，而且利用排序后可以跳过相同元素的特性，也可以避免去重，所以以后在做到需要去重的题目时，除了用哈希表，也可以考虑先排序再处理。

另外也借助这道题练习了一下快排的写法，还是有很多细节注意不到，这里以自己常用的写法为例列举一些需要注意的点，强化一下记忆：

1. 单次循环方面，循环使用的循环是`while(true)`，然后分别移动左指针和右指针，移动完之后先判断是否满足左指针小于右指针的关系，如果满足的话在进行交换，否则跳出循环。
2. 在移动左右指针时，以左指针为例，`while`循环的判断条件除了`nums[left]<nums[start]`之外，另一个条件要是`left<end`而不是`left<right`，因为`left<right`的判断会在移动完指针，交换数据前再进行判断，如果把这个条件放到`while`循环的条件里会影响`left`和`right`的最终位置。
3. 最后进行完一次遍历后，和`start`位置的元素交换的是`right`位置的元素。

### 20220307，四数之和

[leetcode链接](https://leetcode-cn.com/problems/4sum/)

*关键词* ：双指针

跟上一道题基本一样，都是用双指针法把暴力做法的复杂度降低一阶，需要注意的是剪枝条件与上题略有不同。

### 20220308，用栈实现队列

[leetcode链接](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

*关键词* ：栈

做过的题，用一个输入栈和一个输出栈实现队列，可以把各项操作时间复杂度降到O(1)。

### 20220309，反转字符串

[leetcode链接](https://leetcode-cn.com/problems/reverse-string/)

*关键词* ：无

这算哪门子的双指针……

### 20220310，反转字符串II

[leetcode链接](https://leetcode-cn.com/problems/reverse-string-ii/)

*关键词* ：无

答案是从原来的字符串得到一个字符数组，再在这个字符数组的基础上改，可以简单一些。

### 20220311，替换空格

[leetcode链接](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

*关键词* ：无

普通遍历就可以。

### 20220312，颠倒字符串中的单词

[leetcode链接](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

*关键词* ：无

不算特别难的题，不过在Java中确实是不存在空间复杂度为O(1)的做法，答案的做法看着挺花哨，还不如直接建一个`StringBuilder`暴力解决。

### 20220313，实现strStr()

[leetcode链接](https://leetcode-cn.com/problems/implement-strstr/)

*关键词* ：KMP(Knuth-Morris-Pratt)算法

字符串匹配用到的KMP算法，这次是第一次接触这个算法，想了一天想烦了，大致明白了算法执行过程，但是还是不太明白时间复杂度为什么能到O(m+n)，后面还有一道要用到KMP算法的题，先放一放。

### 20220314，用队列实现栈

[leetcode链接](https://leetcode-cn.com/problems/implement-stack-using-queues/)

*关键词* ：无

貌似用队列没办法写出各种操作都是O(1)的栈。自己的实现方式是pop()和top()方法都是O(n)复杂度，而push()操作是O(1)复杂度，而答案则相反，仔细想想确实还是答案的做法更好一些，毕竟top()的调用频率可能会远比增删操作高，所以更应该优化这部分的时间复杂度。

### 20220315，有效的括号

[leetcode链接](https://leetcode-cn.com/problems/valid-parentheses/)

*关键词* ：辅助栈

貌似没有空间复杂度是O(1)的做法，括号类的问题用辅助栈解决也是很顺理成章的。

### 20220316，删除字符串中的所有相邻重复项

[leetcode链接](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

*关键词* ：辅助栈

这个题用栈用得真是非常巧妙，要是这不是在队列和栈专栏下做到这道题还真不会想到能用栈去做，这个思路确实是真的很巧妙了。

### 20220317，逆波兰表达式求值

[leetcode链接](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

*关键词* ：栈

这个题用栈用得也非常巧妙，还是如果不是从队列和栈部分看到这道题还真不一定能想到这么做。

### 20220318，滑动窗口最大值

[leetcode链接](https://leetcode-cn.com/problems/sliding-window-maximum/)

*关键词* ：单调队列，分块预处理，稀疏表

两个多月前刚做过的题，就给忘了。再仔细想想思路。

### 20220319，前K个高频元素

[leetcode链接](https://leetcode-cn.com/problems/top-k-frequent-elements/)

*关键词* ：堆，快速排序

堆的做法倒是很容易想到的做法，但是复杂度比较高，而利用快排思想的做法就要难想一点了，但是复杂度更优，所以还是得会，不过好在这次写快排算法能顺利写出来了，没有出太大的问题。

### 20220320，重复的子字符串

[leetcode链接](https://leetcode-cn.com/problems/repeated-substring-pattern/)

*关键词* ：KMP(Knuth-Morris-Pratt)算法

也是要用到KMP算法，在[strStr](##20220313，实现strStr())的题解的基础上用了相同套路的KMP算法代码勉强做出了这道题。但是到现在还是不算彻底理解KMP算法，但是想太多只会消磨刷题热情，先放一放，后面心情好了再来看看。

### 20220321，翻转二叉树

[leetcode链接](https://leetcode-cn.com/problems/invert-binary-tree/)

*关键词* ：无

简单的遍历。

### 20220322，对称二叉树

[leetcode链接](https://leetcode-cn.com/problems/symmetric-tree/)

*关键词* ：无

递归和迭代两种做法。递归自然不必说，迭代的做法因为有递归做法的存在不容易想到，不过这个做法还是跟普通的迭代DFS遍历二叉树不一样的，因为需要判断对称，所以需要一对一对地把元素加到队列或栈中，这种情况下应该用队列还是栈都无所谓，不过整体的思想还是值得学习的。

### 20220323，二叉树的最大深度

[leetcode链接](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

*关键词* ：BFS

基础的DFS或BFS。

### 20220324，二叉树的最小深度

[leetcode链接](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

*关键词* ：BFS

也是DFS和BFS都可以，不过DFS理论上来说需要遍历所有的节点，但是BFS不用，所以应该还是BFS好一点。需要注意的是这里深度是到最近的叶子节点的距离，而不是二叉树不再满的层数。

### 20220325，完全二叉树的节点个数

[leetcode链接](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

*关键词* ：二分查找，位运算

自己的做法与答案做法时间复杂度相同，不过因为自己的做法用到了递归，所以空间复杂度会更高。答案用到的利用二进制来决定访问节点的方式的做法很巧妙，需要仔细想想这么做的原因，还有二分查找的边界以及返回值问题需要注意。

### 20220326，平衡二叉树

[leetcode链接](https://leetcode-cn.com/problems/balanced-binary-tree/)

*关键词* ：无

在需要函数返回多个值的时候，可以通过返回一个特殊值来代替某个`Boolean`类型的返回值，就可以达到用一个返回值达到两个返回值的效果。

### 20220327，二叉树的所有路径

[leetcode链接](https://leetcode-cn.com/problems/binary-tree-paths/)

*关键词* ：无

题目不难，自己的做法是在递归的过程中维护一个`StringBuilder`，通过合适的方法添加及删除元素，不过删除元素的时候需要考虑的问题略微有点多，而答案用的办法是传递一个字符串给函数，然后每次用这个字符串构造`StringBuilder`，这样做的好处是不需要考虑那么多事，坏处是更浪费时间和空间。

### 20220328，左叶子之和

[leetcode链接](https://leetcode-cn.com/problems/sum-of-left-leaves/)

*关键词* ：无

这题目让人感觉挺没必要的，而且确实也不难。

### 20220329，找树左下角的值

[leetcode链接](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

*关键词* ：BFS

直球的BFS的应用。

### 20220330，路径总和

[leetcode链接](https://leetcode-cn.com/problems/path-sum/)

*关键词* ：DFS

简单的DFS应用。

### 20220331，从中序与后序遍历序列构造二叉树$

[leetcode链接](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

*关键词* ：递归，迭代

有递归和迭代两种做法，其中递归做法中，由于题目中明确说明了树中所有元素都是唯一的，因此可以先建立一个中序遍历的值映射到其在中序遍历数组中位置的`Map`，从而在递归过程中减少计算。而迭代做法比较难理解，现在可以大致理清其程序逻辑，但是可以这样做的原因还不是太清楚，需要再进一步想想。

## 2022年4月

### 20220401，最大二叉树$

[leetcode链接](https://leetcode-cn.com/problems/maximum-binary-tree/)

*关键词* ：单调栈

递归的做法时间复杂度高达O(n^2^)，没有考虑的必要。单调栈的做法很值得思考，通过一个单调递减的栈，当遍历到一个值时，就把栈中比这个值更小的值依次弹出，且把先弹出的节点作为后弹出节点的右子树，并把最后弹出节点作为以遍历到的当前值新建的节点的左节点，并压入栈中，最后以相同的逻辑把栈中所有的节点出栈，这样每个节点都分别进栈出栈一次，时间复杂度与空间复杂度均为O(n)。

### 20220402，合并二叉树

[leetcode链接](https://leetcode-cn.com/problems/merge-two-binary-trees/)

*关键词* ：无

简单的递归。

### 20220403，二叉搜索树中的搜索

[leetcode链接](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

*关键词* ：无

需要注意的是这道题完全可以迭代做，可以把空间复杂度从递归的O(n)降到O(1)。

### 20220404，验证二叉搜索树

[leetcode链接](https://leetcode-cn.com/problems/validate-binary-search-tree/)

*关键词* ：无

利用上下界可以用递归做，但是节点的值可以取到整型的最大最小值，所以不讨好处理，自己的做法是再引入两个表征是否存在上下界的布尔变量辅助判断，答案的做法是取长整型最大最小值作为边界，都可以做。另外也可以中序遍历，判断结果是否递增，这个确实没想到。

### 20220405，二叉搜索树的最小绝对差

[leetcode链接](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

*关键词* ：Morris遍历

实际上是中序遍历的问题，如果用递归的话就需要建立几个类成员变量，而且空间复杂度比较高，因此这里用了Morris遍历，第一次只靠自己写出了Morris遍历的程序，虽然花了挺长时间，不过好歹是成功了。

### 20220406，二叉搜索树中的众数

[leetcode链接](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

*关键词* ：Morris遍历

找众数这个还是有点麻烦的，不过也不算难，放到BST里也就只需要结合一下Morris遍历，整体还行。

### 20220407，二叉树的最近公共祖先

[leetcode链接](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

*关键词* ：DFS

代码看上挺简洁，但是实际上思路还是挺绕的，总之就是递归，并根据两个子节点返回值是否为空来判断当前状态。

### 20220408，二叉搜索树的最近公共祖先

[leetcode链接](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

*关键词* ：无

可以利用二叉搜索树的性质，比上面那道题简单。

### 20220409，二叉搜索树中的插入操作

[leetcode链接](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

*关键词* ：无

需要注意的是二叉树类的题目，当只需要往一个递归的时候完全可以转换为迭代。

### 20220410，删除二叉搜索树中的节点

[leetcode链接](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

*关键词* ：无

真的麻烦的题，写了很久，不过难度倒不算太大，繁而不难。

### 20220411，修建二叉搜索树

[leetcode链接](https://leetcode.cn/problems/trim-a-binary-search-tree/)

*关键词* ：无

明显迭代做法空间复杂度更优，答案竟然只给出了递归的做法。

### 20220412，将有序数组转换为二叉搜索树

[leetcode链接](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

*关键词* ：无

简单递归。

### 20220413，把二叉搜索树转换为累加树

[leetcode链接](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

*关键词* ：Morris遍历

又复习了一遍Morris遍历，这次还是写得很磕绊，不过好歹是写出来了。

### 20220414，组合$

[leetcode链接](https://leetcode.cn/problems/combinations/)

*关键词* ：回溯，位运算

来到回溯专场，第一道题理一理回溯的基本思路，就是自己定义的私有函数参数有点太多了。另外迭代用位运算的算法比较麻烦，后面再想想。

### 20220415，组合总和III

[leetcode链接](https://leetcode.cn/problems/combination-sum-iii/)

*关键词* ：回溯，位运算

跟上一道题差不多的思路，就是花在想怎么剪枝的时间比较长，而且还是没看位运算，后面回来再看。

### 20220416，电话号码的字母组合

[leetcode链接](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

*关键词* ：回溯

也是回溯，更简单。

### 20220417，组合总和

[leetcode链接](https://leetcode.cn/problems/combination-sum/)

*关键词* ：回溯

同样是回溯，不过这个可以通过对数组进行排序来剪枝，加快执行速度。

### 20220418，组合总和II

[leetcode链接](https://leetcode.cn/problems/combination-sum-ii/)

*关键词* ：回溯

也是经典回溯题，不过需要一定的技巧来避免重复，这里答案采用了一个`HashMap`，自己是先排序再跳过重复，都可行。

### 20220419，回文子串

[leetcode链接](https://leetcode.cn/problems/palindromic-substrings/)

*关键词* ：Manacher算法

回文串题目，中心扩展法相比于更暴力的三层遍历的做法要优一些，但是还是要比Manacher算法复杂度高，另外Manacher算法在实现的时候不需要像答案那样去拼字符串，直接遍历`2n-1`个中心位置就可以。对于Manacher算法还不是太熟练，需要多看看本题的代码。

### 20220420，分割回文串

[leetcode链接](https://leetcode.cn/problems/palindrome-partitioning/)

*关键词* ：回溯，动态规划

看到回文串本以为要用到Manacher算法，还特地回顾了一下，可惜没用上。而且也没想到可以动态规划减少重复计算，应该想到的。

### 20220421，复原IP地址

[leetcode链接](https://leetcode.cn/problems/restore-ip-addresses/)

*关键词* ：回溯

其实这题也没什么难的，就是有一点麻烦，需要注意的地方有点多，写代码还是不够熟练，要花很多时间。

### 20220422，子集

[leetcode链接](https://leetcode.cn/problems/subsets/)

*关键词* ：回溯，位运算

跟之前的题不太一样的回溯，还是用位运算更合适一点。

### 20220423，子集II

[leetcode链接](https://leetcode.cn/problems/subsets-ii/)

*关键词* ：回溯

现在才发现上题答案用的迭代跟自己用的迭代不一样，这道题没法用自己上一题用得那种迭代，不过还可以用答案上一题用的迭代，当然递归回溯都可以做。

### 20220424，递增子序列

[leetcode链接](https://leetcode.cn/problems/increasing-subsequences/)

*关键词* ：回溯

最近被回溯搞得有点懵，再加上感冒，现在什么都不会了。这道题的去重是需要注意一下的。

### 20220425，全排列

[leetcode链接](https://leetcode.cn/problems/permutations/)

*关键词* ：回溯

也是比较简单的回溯问题，不过这题是每一层都需要遍历所有元素，用一个已访问数组来标记。

### 20220426，全排列II

[leetcode链接](https://leetcode.cn/problems/permutations-ii/)

*关键词* ：回溯

跟上面那道题的区别就在于多了重复数字，依然采用了自己擅长的通过排序避免重复的做法。

### 20220427，重新安排行程$

[leetcode链接](https://leetcode.cn/problems/reconstruct-itinerary/)

*关键词* ：回溯，欧拉图

回溯的方法可以做，技巧在于把回溯方法的返回值设置为一个`boolean`类型的值，另外回溯一个比较麻烦的地方在于题目要求的按字典排序，自己的做法是先建立好邻接表，然后对每个节点的邻接表列表进行排序，答案的做法是用了一个优先队列，省去了排序的麻烦。答案中给出的Hierholzer算法的做法是专门针对欧拉图的做法，时间复杂度上应该比回溯法更优，后面有时间了应该回来看看这个算法，顺便仔细分析一下回溯的时间复杂度。

### 20220428，N皇后

[leetcode链接](https://leetcode.cn/problems/n-queens/)

*关键词* ：回溯，位运算

回溯的困难题都不太难啊，不过这几天也是越来越懒了，答案跟自己不一样的做法都懒得再写一遍了。这题跟答案不一样的地方有两处，第一处是答案用了位运算，即用一个整数的各位来表示某个列或者某个对角线上有没有元素，而自己的做法是用了一个`boolean`类型的数组，相比之下理论上来说答案的空间复杂度还是低一些；另一个不同的地方在于记录皇后位置的方法，自己还是用了`boolean`类型的二维数组，而相比之下答案的做法就好很多，因为最终的结果中肯定是每一行只有一个皇后，所以只需要用一个`int`类型数组即可记录各行皇后所在的列，把空间复杂度由O(n^2^)降到了O(n)。

### 20220429，解数独$

[leetcode链接](https://leetcode.cn/problems/sudoku-solver/)

*关键词* ：回溯，位运算

终于到了回溯的最后一题了，这题也不算太难，跟上一题有很多类似的地方，就是自己的做法是遍历所有的位置，答案的做法是在第一次遍历的时候记录没有数字的位置，效果是差不多的。另外答案中位运算的做法以及优化需要后面再看一下。有几个位运算技巧在这里记录一下：

`b & (-b)`：得到`b`最低位的`1`，例：`10111100 & 01000100 = 00000100`

`b & (b - 1)`：将`b`最低位的`1`置为`0`，例：`10111100 & 10111011 = 10111000`

### 20220430，分发饼干

[leetcode链接](https://leetcode.cn/problems/assign-cookies/)

*关键词* ：贪心

像是比较经典的贪心算法，既然要满足尽可能多的人，那就从最小的开始满足，拿能满足需求最小的人的最小的饼干进行分配，重复这个过程，直到分配结束。

## 2022年5月

### 20220501，摆动序列

[leetcode链接](https://leetcode.cn/problems/wiggle-subsequence/)

*关键词* ：贪心，动态规划

答案解释太麻烦了，懒得去看了，不过自己的代码是可以优化的，最明显的就是可以通过判断原数组长度是否小于2来减少大量代码。

### 20220502，最大子数组和

[leetcode链接](https://leetcode.cn/problems/maximum-subarray/)

*关键词* ：动态规划，分治

这道题自己的做法可能差不多也算是动态规划，不过太久没做动态规划的题了，有点想不清楚了，不过整体思路大致是一样的。另外答案给出的递归分治的方法，大体思路还是挺普通的，就像归并排序一样，不过就是由两个子数组结果推导整个数组的过程以及需要维护的量的选取比较精巧，这里确实值得学习。

### 20220503，买卖股票的最佳时机II

[leetcode链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

*关键词* ：动态规划，贪心

太久没写过动态规划了，对于状态变量和转移方程的选取还是太生疏了，也没想到贪心的做法，极度受挫。另外这道题里面有注明可以当天卖出之后再买入，需要再考虑考虑这个条件对解法有什么影响。

### 20220504，跳跃游戏

[leetcode链接](https://leetcode.cn/problems/jump-game/)

*关键词* ：贪心

这也算贪心啊，不过这题本身确实不算难。

### 20220505，跳跃游戏II

[leetcode链接](https://leetcode.cn/problems/jump-game/)

*关键词* ：贪心

还是不太理解什么是贪心，这题也没想出来。与上一题类似，这一题也要维护最远能到达的距离，不过与上一题不同的是，这一题还要维护需要走的步数，思路是记录每一步能走到的最远距离，然后在遍历该步所在位置与此时的最远距离(记为`end`)之间的位置时，也就是遍历下一步的落脚点时，继续维护最远距离，等走到`end`之后，就能知道下一步所有落脚点中可能走到的最远距离，此时再更新`end`，而至于落脚点具体是在哪其实不重要，再往下就要继续遍历再下一步所能走到的位置，直到这个位置能在目的地之后为止。思路挺绕的，需要再多想想。

### 20220506，K 次取反后最大化的数组和

[leetcode链接](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

*关键词* ：贪心

这题不像看起来那么简单啊，需要考虑的细节还是很多。另外答案的做法确实是把复杂度降下去了，但是实际运行时间感觉也短不了多少。不如正儿八经排个序直观。

### 20220507，加油站

[leetcode链接](https://leetcode.cn/problems/gas-station/)

*关键词* ：贪心

又是没做出来的一道题，不过还是没有贪心的感觉。总结一下就是首先从`0`出发，走到走不动为止，记录此时继续走下去所需要的油量，如果存在一个位置能走完一圈，那么剩余的位置总的油量供给一定是大于油量消耗，并且多出来的值时能补上在走不下去的位置所需要的油量的，所以只需要跳到下一个位置，重复该过程，等走到底之后，判断最后的油量盈余是否大于前面所有的油量需要即可。

### 20220508，分发糖果

[leetcode链接](https://leetcode.cn/problems/candy/)

*关键词* ：贪心，左右遍历，字节面试重灾区

自己的做法是先遍历一遍，存一下每一个谷，然后分别从每个谷出发向两边延申，这种做法时间复杂度与空间复杂度都是O(n)，但是实际上最多可能要遍历三遍，还需要一个额外的`list`存放谷的位置实际耗时较长。答案中给了两种做法，其中从左右分别开始遍历的做法是应该要会的，这种做法很常用，也很直观，没有什么难理解的地方，只是需要记一下，或者说注意一下。另一种做法很难想到，但是确实复杂度更优，但是代码写起来不太优雅，但是确实复杂度更优，但是通用性不强，但是确实复杂度更优，总而言之，哪怕只是为了这道题，也要好好理解一下最后一种解法。另外，看评论区很多人在面字节的时候遇到了这道题，看来这题是在字节的题库里面，更要好好记一下。

### 20220509，柠檬水找零

[leetcode链接](https://leetcode.cn/problems/lemonade-change/)

*关键词* ：贪心

这题能感觉出来贪心了，不过这题有点过于简单了。

### 20220510，根据身高重建队列

[leetcode链接](https://leetcode.cn/problems/queue-reconstruction-by-height/)

*关键词* ：无

每日一问，这也能叫贪心？这题是做过的题，这次做的时候一开始也想过排序的做法，虽然没想细节，但是想着时间复杂度太高，但是没想到没有更优的做法了。答案有从小到大和从大到小两种做法，不过需要注意，不管是哪种，以从小到大排序为例，是优先按身高升序排列，然后按前面的人数降序排列，这样做的目的是，插入时对于身高相同的人，会优先插入排到后面的人，不会影响接下来的人的插入；而对于从大到小排序的情况，是建立一个队列，然后从大到小插入，由于插入之前已经插入了所有比待插入的人身高高的，因此只需要插入到索引为这个人前比这个人高的人数的位置，而对于身高相同的人，后插入的自然在后面，而且后插入的前面比他身高高的人也更多，因此合理。另外需要注意的一点是，在从小到大排序，数空位置时，可以将二维数组初始化为`new int[size][]`，这样根据数组某一项是不是`null`就可以判断这个位置有没有被占，这样就不用给整个数组填上类似`-1`的初始值这种消耗时间的做法。

### 20220511，用最少数量的箭引爆气球

[leetcode链接](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

*关键词* ：贪心

这题一开始完全没思路，看了答案好像明白了一点，确实是有点贪心的意思。首先按照气球右边界对气球进行排序，然后对于气球右边界最靠左的气球，需要有一支箭将其引爆，为了让这支箭引爆尽可能多的气球，需要把这支箭的位置尽量往右靠，因为只要这支箭的位置在这个气球的右边界以左，就不可能会有气球整个落在这支箭的左边，否则就和当前气球是右边界最靠左的气球矛盾，所以把这支箭的位置设置在当前气球的右边界上，为了移除所有可以被引爆的气球，继续遍历，遇到左边界小于上一支箭的位置的气球，就说明其能被上一支箭引爆，若遇到气球左边界大于上一支箭的位置，就说明其不能被引爆，同时，这个气球也肯定是上一支箭不能引爆的气球里面右边界最靠左的气球（这时在这个气球后面可能还有能被上一支箭引爆的气球，但是这不影响这个结论），所以重复之前的过程，射出下一支箭，将其位置设置为这个气球的右边界，继续遍历，直到遍历完所有气球，统计箭的数量即可。

### 20220512，无重叠区间

[leetcode链接](https://leetcode.cn/problems/non-overlapping-intervals/)

*关键词* ：贪心

虽然花的时间多了一点，不过好歹是自己想出来了。再结合上一题的经验，区间相关的题目看来都避免不了排序，想想也合理，不排序的话确实没法入手，排完序之后就不难想到贪心的做法了。

### 20220513，划分字母区间

[leetcode链接](https://leetcode.cn/problems/partition-labels/)

*关键词* ：贪心

这题还是简单的，遍历两遍完事。

### 20220514，合并区间

[leetcode链接](https://leetcode.cn/problems/merge-intervals/)

*关键词* ：无

又是区间的题，有了以前的经验之后容易了很多。

### 20220515，单调递增的数字

[leetcode链接](https://leetcode.cn/problems/monotone-increasing-digits/)

*关键词* ：无

这也算贪心？这题最开始的思路不算太好想，想到思路之后实现细节上也有挺多需要注意的点，不过总体而言还是不算难的。

### 20220516，买卖股票的最佳时机含手续费

[leetcode链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

*关键词* ：动态规划，贪心

这题动态规划的做法是容易想到的，跟[前面那道题](###20220503，买卖股票的最佳时机II)基本一样，而贪心做法就巧妙很多了，前面那道题的贪心思想很直接，遇到一个上坡就要进行一次交易，遇到连续上坡的时候也就相当于在其中某一天卖掉股票后随即再以相同的价格买入股票，而在这一题则是从这个思想延伸，这一题与之前不同的是因为有手续费的存在，不能将大的上坡转成连续小上坡，而手续费每次交易只有一次，因此，在找到局部最优解后，为了应对有更优解的问题，在买入股票的时候就计算上手续费，遇到股票价格比买入总费用高就卖掉股票，为了应对后面还有上坡的情况，要模拟卖掉之后随即在当天买入，但是由于这次操作是模拟的，所以这次不能加手续费如果后面遇到某一天的股票价格加上手续费比上次买入价格更低，就更新买入价格即可，这样也适配了没有连续上坡的情况。

### 20220517，监控二叉树

[leetcode链接](https://leetcode.cn/problems/binary-tree-cameras/)

*关键词* ：动态规划

这个动态规划太高级了，第一眼想的是回溯，但是时间复杂度无疑太高了，用了动态规划就好了很多，这里的动态规划确实难想，尤其是三个状态，自己只想了一个大概，明天就开始正式做动态规划的题目了，做完动态规划再来看应该会好一点。

### 20220518，斐波那契数

[leetcode链接](https://leetcode.cn/problems/fibonacci-number/)

*关键词* ：动态规划，快速幂

动态规划的做法自然不必多说，需要关注的是快速幂的做法，首先要考虑的是这种方法的通用性，在动态规划类的题目中，如果要用矩阵快速幂的做法，需要递推公式是线性的，可以写作一个矩阵，而且有着明确的指数次数，不知道这样的题目多不多，后面做做别的题再回来看；在除了动态规划之外的地方，只要是用到求幂的地方，应该都可以用快速幂，不过好像用得不多，但是还是需要留意一下。

### 20220519，爬楼梯

[leetcode链接](https://leetcode.cn/problems/climbing-stairs/)

*关键词* ：动态规划，快速幂

跟上一题基本完全一样的动态规划和快速幂做法。

### 20220520，使用最小花费爬楼梯

[leetcode链接](https://leetcode.cn/problems/min-cost-climbing-stairs/)

*关键词* ：动态规划

简单的动态规划。

### 20220521，不同路径

[leetcode链接](https://leetcode.cn/problems/unique-paths/)

*关键词* ：动态规划，数学题

动态规划的做法不用多说，这边组合数的做法的溢出问题需要好好考虑，答案用的下面这种代码：

```java
long result = 1;
for (int i = m + 1, j = 1; j <= n; i++, j++) {
    result = result * i / j;
}
return (int) result;
```

这种代码可以保证每次循环后的`result`都比之前大，因此如果最后的结果不溢出，那么每次循环后的结果也不会溢出，但是还有一个问题，就是循环中如果先算除法再算乘法，那么就会有精度丢失，如果先算乘法再算除法，有可能会出现算完乘法结果就已经溢出的情况，因此还是要先将`result`变量定义为`long`类型。

### 20220522，不同路径II

[leetcode链接](https://leetcode.cn/problems/unique-paths-ii/)

*关键词* ：动态规划

也是简单的动态规划问题，不过需要注意一些细节问题。

### 20220523，整数拆分

[leetcode链接](https://leetcode.cn/problems/integer-break/)

*关键词* ：动态规划，数学题

正经的动态规划应该是逃不开O(n^2^)的时间复杂度的，数学解法很强，但是不知道面试的时候对数学类解法要求到什么程度。

### 20220524，不同的二叉搜索树

[leetcode链接](https://leetcode.cn/problems/unique-binary-search-trees/)

*关键词* ：动态规划

这个好像确实也只能是O(n^2^)的时间复杂度。

### 20220525，分割等和子集

[leetcode链接](https://leetcode.cn/problems/partition-equal-subset-sum/)

*关键词* ：动态规划，背包问题

背包问题中的基本问题，主要在于理解背包问题的原理，如果能理解原理，那么这题也没什么难的。需要注意的是在进行动态规划的空间优化时，嵌套双层遍历中，每次遍历需要先判断`j`是否大于`nums[i]`，都则会出现数组越界的问题，因此与其将代码写作如下形式：

```java
for (int j = target; j >= 1; j--) {
    if (j >= nums[i]) {
        dp[j] |= dp[j - nums[i]];
    }
}
```

不妨改为：

```java
for (int j = target; j >= nums[i]; j--) {
    dp[j] |= dp[j - nums[i]];
}
```

这样可以进一步节省运算时间。

### 20220526，最后一块石头的重量II

[leetcode链接](https://leetcode.cn/problems/last-stone-weight-ii/)

*关键词* ：动态规划，背包问题

跟上一题做法基本一样的背包问题，但是要能看出来这是一个背包问题需要花点时间。

### 20220527，目标和

[leetcode链接](https://leetcode.cn/problems/target-sum/)

*关键词* ：动态规划，背包问题

也是背包问题，背包问题部分难度并不大，但是需要注意的细节还是挺多的，做的时候也不够有耐心。而且如果面试的时候不提供没过的测试用例的话，就会很难处理，只能平时练习尽量多地注意细节。

### 20220528，一和零

[leetcode链接](https://leetcode.cn/problems/ones-and-zeroes/)

*关键词* ：动态规划，背包问题

这题要不是在这里遇到估计真想不到要这么做，总结一下01背包问题地特点，一般时从一个数组里面取，来满足某种形式地和为某个值或者某个范围的情况。不过背包问题的题目也不多，做过这些应该也差不多了。

### 20220529，零钱兑换II

[leetcode链接](https://leetcode.cn/problems/coin-change-2/)

*关键词* ：动态规划，完全背包问题

接下来是完全背包问题了，从无放回的取变成了有放回的取，或者说数组元素数量变成无限了。做法上整体上与01背包问题差不太多，就是内层循环的方向变了一下，原理也不难理解，从动态规划的原理很容易想过来。

### 20220530，组合总和IV$

[leetcode链接](https://leetcode.cn/problems/combination-sum-iv/)

*关键词* ：动态规划，完全背包问题

这题相比于前面那道完全背包问题，原理上不同的地方在于前面那道题要求组合，像大多数01背包问题一样，而这道题要求排列，而01背包问题好像是不能求排列的，这个后面要再想一下；做法上不同的是两层遍历的顺序倒了一下，先遍历目标值，再遍历数组元素，也不难理解，就是相当于对于每一个目标值，遍历其排列的最后一个数的可能取值，也就达到了排列而不是组合的目的。不过这是数组中没有重复元素的情况下，但是不限次数的取有没有重复数字也没有关系，那么这么说来01背包应该是要考虑重复元素的问题的，但是求组合是不需要的，如果求排列呢，这又回到前面的01背包能不能求排列的问题了，还可以和回溯问题放一起思考一下联系和区别。

### 20220531，零钱兑换

[leetcode链接](https://leetcode.cn/problems/coin-change/)

*关键词* ：动态规划，完全背包问题

这题算是相对简单的完全背包问题，就是需要稍微注意一下细节。

## 2022年6月

### 20220601，完全平方数

[leetcode链接](https://leetcode.cn/problems/perfect-squares/)

*关键词* ：动态规划，完全背包问题，数学题

还是完全背包问题，有前面的基础看这题就没什么难度了，但是感觉最近背包问题做得多了，看到题目就想背包得做法，但是一旦知道要用背包得做法之后就没什么难度了，最困难得辨别背包问题得步骤被忽略了，只能后面不分类刷题的时候补回来了。另外这道题也有数学解法，毕竟输入只有一个数字，想没有数学做法都难。

### 20220602，单词拆分

[leetcode链接](https://leetcode.cn/problems/word-break/)

*关键词* ：动态规划，完全背包问题

这题相比于背包问题更接近于普通的动态规划，难度并不大，不过在优化方面还是有很多可以学习的地方，比如可以利用两个哈希表，分别存储单词数组里的所有单词以及所有单词长度，在判断是否有单词匹配的时候，先遍历长度哈希表，对于每一个长度，先判断`dp[i-length]`是否为`true`，若是，则再判断单词哈希表中是否有`s.subString(i-length, i+1)`这个单词，若有，则将`dp[i]`置为`true`，否则置为`false`，这种做法可以节省一部分时间。

### 20220603，打家劫舍

[leetcode链接](https://leetcode.cn/problems/house-robber/)

*关键词* ：动态规划

基础动态规划。

### 20220604，打家劫舍II

[leetcode链接](https://leetcode.cn/problems/house-robber-ii/)

*关键词* ：动态规划

形成一个环的话就可以从一个点入手，拆成两种情况，取最大值即可。

### 20220605，打家劫舍III

[leetcode链接](https://leetcode.cn/problems/house-robber-iii/)

*关键词* ：树形动态规划

树形动态规划的问题，这种题做得比较少，一开始还是有点陌生，不过想想也能想明白。

### 20220606，买卖股票的最佳时机

[leetcode链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

*关键词* ：无

与其他买卖股票的题目有一些差异，很简单。

### 20220607，买卖股票的最佳时机II

[leetcode链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

*关键词* ：动态规划，贪心

前不久刚做过，动态规划的做法比较简单，经典的二维动态规划，贪心做法比较巧妙。

### 20220608，买卖股票的最佳时机III

[leetcode链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

*关键词* ：动态规划

也是比较简单的动态规划，只是相比于上一题的动态规划做法多了两种状态。