# Leetcode刷题笔记

[toc]

## 20211206，除自身以外数组的乘积

[leetcode链接](https://leetcode-cn.com/problems/product-of-array-except-self/)

*关键词* : 双向遍历

做过的题目，从两头各遍历一次，第一次做很难做出来，做过一次后再遇到就容易想到了。

## 20211207，搜索二维矩阵

[leetcode链接](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

*关键词* ：二维数组

也是做过的题，第一次做的时候理解还不深刻，没有意识到自己的解法的问题所在。自己的做法是根据中心点与目标值大小的比较把整个矩阵分成4块，然后可以根据比较结果丢掉一块，分别对剩余三块进行递归，以为这样时间复杂度就是O(log(mn))，实际上不是，见下图：

```text
                                               n
                                                    
                                                    
             n/4                              n/4                               n/4
                  
                                                                                                  log4(mn)层
                  
n/16         n/16        n/16    n/16          n/16         n/16      n/16        n/16      n/16
     
     
     ..................................................................................................
```

最底层总共有3^log4(mn)^ =(mn)^log4(3)^ 个元素，因此根据等比数列求和公式，总的时间复杂度还是O((mn)^log4(3)^)，很接近O(mn)，并不是想的O(log(mn))。而答案的做法则是很巧妙地从右上角开始，每进行一次比较就丢弃掉一行或者一列，时间复杂度达到O(m+n)，代码也很简洁。

## 20211208，完全平方数

[leetcode链接](https://leetcode-cn.com/problems/perfect-squares/)

*关键词* ：动态规划，数学题

动态规划题，一开始还是用的有记忆的递归做的，理论上时间复杂度应该是一样的，但是实际上递归会慢很多，以后遇到这种题就不需要犹豫，直接动态规划就好了。另外答案还给了数学方法的解法，大大降低时间复杂度。但是用到的数学原理实在是太专业了，非数学相关专业一般接触不到的做法，所以也挺无聊的。

## 20211209，寻找重复数

[leetcode链接](https://leetcode-cn.com/problems/find-the-duplicate-number/)

*关键词* ：二分法，位运算，Floyd判圈算法

要满足空间复杂度为O(1)，难度挺大的题。如果时间复杂度为O(nlog(n))，可以采用二分法与位运算的做法，进一步将时间复杂度提高到O(n)，就只有采用Floyd判圈算法。这三种做法思路都非常巧妙，下面分别进行分析。

1. 二分法

    根据数组中比`i`小的元素数量`count[i]`的大小与`i`的大小关系来判断`i`是比要找的数大还是小，从而把`[1, n]`分成两半，对目标所在的一半继续进行递归操作，直到找到目标值。有个细节需要注意，就是用来存储结果的变量`result`的更新的问题，由于`result`肯定是在`count[i] > i`的部分，因此只有进入到这一部分时，才需要将`result`更新为当前的`middle`变量的值，进入另一部分时只需要更新范围，不需要更新结果变量。

2. 位运算

    自己做的时候想过位运算方向的解法，可惜没想明白。这种做法是逐位求出目标值，巧妙点在于对每一位，对比数组`nums`中该位置为`1`的元素的数量，将其与数组`[1, n]`中该位置为`1`的元素数量对比，若前者大，则说明目标值该位置为`1`，否则为`0`，利用这个原理，就能很容易地做出这题。

3. Floyd判圈算法

    最快的做法，时间复杂度达到了O(n)，但我感觉也是没看过答案绝对做不出的方法。这种做法把数组看作一个有向图的`n + 1`条边，分别表示由`i`指向`nums[i]`，`n + 1`个节点共有`n + 1`条边，而且必有一个节点入度为`2`以上，因此该有向图必存在一个圈，且入圈的节点就是入度为`2`的节点，也就是我们要找的重复数，这个问题就变成了寻找环形链表的入环节点的问题，就可以用时间复杂度为O(n)的Floyd判圈算法解决该问题。

## 20211210，最长递增子序列

[leetcode链接](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

*关键词* ：二分法，动态规划，改进动态规划

O(n^2^)时间复杂度的解法不难实现，普通的动态规划就可以，而O(nlog(n))时间复杂度的解法就很困难了。前者选取的状态变量为以元素`nums[i]`结尾的最长递增子序列，而后者则完全换了方法，选取长度为`l`的最长递增子序列的结尾元素作为状态变量，并在遍历的过程中对状态变量数组进行更新，这种情况下的状态变量数组是有序的，因此就可以采用二分查找，把时间复杂度降下来。这种题至少需要大量的积累才有可能能有最优解法的思路，还需努力。

## 20211211，最佳买卖股票时机含冷冻期

[leetcode链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

*关键词* ：动态规划，空间优化动态规划

比较难的动态规划问题。选取的状态变量是能比较容易想到的第`i`天结束后的最大收益，不过困难的是这个状态变量又分成了三种情况，分别是第`i`天结束后持有股票，未持有股票并处于冷冻期和未持有股票而且不处于冷冻期，根据第`i - 1`天这三种情况下的状态就可以推出第`i`天的状态。最后只需要求出最后一天两种不持有股票情况下的最大值就可以得出答案。综合来看状态变量的选取以及转移方程都比较难想，还需要更多积累才能做好这道题。

## 20211212，零钱兑换

[leetcode链接](https://leetcode-cn.com/problems/coin-change/)

*关键词* ：动态规划

基本上是最基础的不能进行空间优化的动态规划了，和前几天做的[完全平方数的题](##20211208，完全平方数)的动态规划解法差不多。

## 20211213，打家劫舍III

[leetcode链接](https://leetcode-cn.com/problems/house-robber-iii/)

*关键词* ：记忆递归，动态规划，空间优化动态规划，深度优先搜索(DFS)

把动态规划搬到了二叉树结构，与普通动态规划区别只是在于将普通数组换成了哈希表。由于对二叉树的深度优先遍历本身就要用到递归栈，因此本题用带记忆的递归也可以做，本质上是一样的，就是动态规划是后序遍历，而记忆递归某种程度上算是先序遍历。不过动态规划可以进行空间优化，由于对于每个节点的分析只需要用到它的两个子节点的结果，因此可以去掉哈希表。

## 20211214，前K个高频元素

[leetcode链接](https://leetcode-cn.com/problems/top-k-frequent-elements/)

*关键词* ：堆，快速排序

可以用大根堆做，也可以用小根堆做，大根堆就是把所有元素放进堆中，然后取出前K个放进数组，这种情况下的时间复杂度是O(nlog(n))，而小根堆则是将容量限制为K，维护前K个出现频率最高的元素，这种情况下的时间复杂度是O(nlog(k))，所以理论上来说小根堆更好一些。另一种做法是利用快排的原理，每次确定一个元素的位置，直到确定的元素位置恰好为K时，即可确定前K个高频元素，这种解法理论上的时间复杂度可以降低到O(n)。

## 20211215，字符串解码

[leetcode链接](https://leetcode-cn.com/problems/decode-string/)

*关键词* ：栈，递归

辅助栈的做法和递归的做法差不多。这种题说难也不难，但是麻烦是真麻烦，要把代码写得简洁更麻烦，不知道笔试面试喜欢不喜欢考这种题。

## 20211216，除法求值（待解决）

[leetcode链接](https://leetcode-cn.com/problems/evaluate-division/)

*关键词* ：加权并查集

很难啊，先留一留，后面慢慢看。

## 20211217，根据身高重建队列

[leetcode链接](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

*关键词* ：排序

想法不算很难的一道题。有个细节需要注意，就是排序的时候可以优先通过身高排序，然后根据第二项也就是身前有多少人进行逆序排序，这样就可以避免另外处理身高相同的情况，这个想法很值得学习。另外让我不太明白的一点在于从低到高排序然后通过数`null`来插入数组的做法为什么会比从高到低排序然后插入列表然后转化为数组的做法慢这么多，能想到的可能的原因在于第一种方法耗费的时间大约是n^2^，而第二种方法耗费的时间大约是n^2^/2，或者还是说Java的ArrayList的插入有优化？不理解。

## 20211218，分割等和子集

[leetcode链接](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

*关键词* ：动态规划，空间优化动态规划，高时间复杂度，背包问题

挺难的题，主要在于这种动态规划方法不好想，无论是状态变量还是转移方程，而且这道题的时间复杂度还很高，显得更吓人了。而且答案中从普通动态规划转向空间优化的动态规划过程中有一些细节需要注意。

## 20211219，路径总和III

[leetcode链接](https://leetcode-cn.com/problems/path-sum-iii/)

*关键词* ：深度优先搜索(DFS)，空间换时间，前缀和

也不算简单的题，暴力一点是要分别从每个节点开始向下搜索，时间复杂度为O(n^2^)，而这道题的解法则很巧妙地用了前缀和的做法，这样就可以利用空间换时间的思想，建立一个哈希表，把内部循环改成时间复杂度为常数的哈希表查询，从而将时间复杂度降为O(n)。前缀和的采用是本题的关键。

## 20211220，找到字符串中所有字母异位词

[leetcode链接](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

*关键词* ：滑动窗口

普通的滑动窗口的方法很容易想到，但是时间复杂度较高，本题答案的关键步骤就在于对检测字母异位词的过程的优化，采用一个记录当前字符串与目标字符串不同数目的字母的个数的变量以及一个记录各字母数目差别的数组，每次移动窗口只需要访问两个位置来维护这个变量，把时间复杂度降了下来。类似的时间复杂度降低的需求还是挺多的，不过解决方法似乎不尽相同。

## 20211221，目标和

[leetcode链接](https://leetcode-cn.com/problems/target-sum/)

*关键词* ：动态规划，空间优化动态规划，高时间复杂度，背包问题

和前几天的[那道题](##20211218，分割等和子集)差不多的题，都属于背包问题，解决方法也类似，唯一的区别在于那道题是找没有，而这道题是找有多少种。有个细节需要注意，以空间优化前的做法为例，需要建立一行辅助行，用于表示有0个元素可选时能组成各数的选法数目，前几天的题没有这一行是没关系的，可以通过对第一行多做一些处理来等效，但是今天这道题在`[0, 0, 0, 0, 0, 1]`这类输入时就会出现问题。

## 20211222，把二叉搜索树转换为累加树

[leetcode链接](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

*关键词* ：深度优先搜素(DFS)，Morris遍历

普通的中序遍历做法很容易，不过空间复杂度较高，递归占的空间为O(n)。比较有趣的做法是Morris遍历做法，这种方法把空间复杂度降到了O(1)，但是其消耗的时间稍微长一点，但是渐进复杂度还是O(n)，答案复杂度分析好像有点问题，好像应该是没有右子树的节点会访问一次，而有右子树的节点会访问两次。这种做法很巧妙，类似于利用二叉树的叶子节点的闲置指针把二叉树展开为中序遍历的顺序的链表，而且时间复杂度还是与节点个数成正比的线性复杂度，很值得多思考的方法，以后遇到二叉树的问题也可以多尝试这种方法。

## 20211223，和为K的子数组

[leetcode链接](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

*关键词* ：前缀和

和前几天的[那道题](##20211219，路径总和III)差不多的做法，那道题是在树上应用了前缀和的做法，而这道题是在数组上应用前缀和的做法，这道题还相对简单一点。从这两道题可以总结出的经验是前缀和的做法基本都应用于**连续**的和，可以把时间复杂度从其他做法的O(n^2^)降到O(n)，不过要额外占用O(n)的空间复杂度。

## 20211224，最短无序连续子数组

[leetcode链接](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

*关键词* ：排序，逆序对

从逆序对的角度来考虑好理解一点。要把数组分成三部分，只要把中间部分排序那么整个数组就是有序的，所以所有的逆序对都必须落在中间部分，要找中间部分的边界，就要找所有逆序对中最左边的边界与最右边的边界。以寻找右边界为例分析一下，自己的做法是新建一个数组，首先从左到右遍历，记录每个位置之前的最大值，得到一个最大值数组，然后从右往左遍历，对比原数组与最大值数组的不同，第一个不同的位置就说明这个位置之前有个比他更大的元素，说明这个就是所有逆序对的右边界；而答案的做法则是在从左向右遍历的同时用一个变量记录到目前为止的最大值，并用一个变量来维护右边界的位置，当遍历到的位置比最大值小时，说明这个位置是某个逆序对的右边，遍历一遍后就能找到所有逆序对最右边的边界。自己的做法需要遍历两次，而且需要一个额外的数组存放最大值，而答案的方法只需要遍历一次，而且只需要常数级的空间，所以显然答案的方法更优。

## 20211225，任务调度器

[leetcode链接](https://leetcode-cn.com/problems/task-scheduler/)

*关键词* ：数学题

不好说这是什么解法，自己想的时候太执着于排序之后再做了，而且没考虑明白字母种类比n大的情况，也是考虑思路错了。按答案写的解法不算太快，比较快的解法是用长为26的数组代替哈希表，这一点值得注意。

## 20211226，回文子串

[leetcode链接](https://leetcode-cn.com/problems/task-scheduler/)

*关键词* ：Manacher算法

一开始看到这题就想用动态规划做，倒是也能做，但是时间复杂度高达O(n^2^)，空间复杂度也有O(n)，都算不上好。答案给出的第一种遍历所有回文子串的可能的中心，然后向两边扩展的方法时间复杂度也是O(n^2^)，而且只使用了常数的空间。关于这个解法需要注意的奇数长度回文串与偶数长度回文串的结合方法，通过遍历包括字母位置与字母之间的位置共`2n-1`个中心，把两种情况合到一个循环里。而答案的第二种做法，也就是Manacher算法，把时间复杂度压到了O(n)。这种算法通过在从左向右遍历的过程中记录一个到目前为止的回文子串所能到达的最右边的位置，结合前面已经计算过的与以这个最右边位置对应的回文子串中心对称的点的回文子串的长度，避免一定的重复计算。不过现在确实对这个算法理解不够深刻，还要多回来复习复习。

## 20211227，每日温度

[leetcode链接](https://leetcode-cn.com/problems/daily-temperatures/)

*关键词* ：单调栈

自己的做法算是动态规划从右向左遍历温度数组，对于遍历到的元素，通过其右边的元素的状态来确定其状态，若右边元素比该元素大，则待求位置的结果就是1，否则，再判断右边位置的天数是不是0，如果是的话那么可以直接给当前位置赋0，否则就找到右边位置的结果对应的位置，重复上述过程。这种做法比较宽松的一个时间复杂度上限是O(n^2^)，但是暂时还不知道准确的时间复杂度该是多少。答案用的单调栈的方法，时间复杂度为O(n)，是很合理的做法，但是什么情况下要用单调栈的做法还需要多归纳。

## 20211228，两数相加

[leetcode链接](https://leetcode-cn.com/problems/add-two-numbers/)

*关键词* ：链表

挺普通的题。个人感觉这题最大的意义在于锻炼提高代码简洁度的水平。

## 20211229，无重复字符的最长字串

[leetcode链接](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

*关键词* ：滑动窗口

自己想的办法实际上跟答案差不多，都可以用滑动窗口来理解。就是自己的方法一开始用了一个队列比较多余，可以直接双指针解决的。可以优化的点在于用128位的数组代替哈希表。

## 20211230，全排列

[leetcode链接](https://leetcode-cn.com/problems/permutations/)

*关键词* ：回溯

普通的DFS回溯算法，答案做法相比于自己的做法优化了空间复杂度，通过在原数组直接修改避免了用一个额外的标记数组或者用个链表来标记遍历过的数组元素。

## 20211231，两数之和

[leetcode链接](https://leetcode-cn.com/problems/two-sum/)

*关键词* ：哈希

普通的哈希表的应用。

## 20220101，有效的括号

[leetcode链接](https://leetcode-cn.com/problems/valid-parentheses/)

*关键词* ：辅助栈

辅助栈的简单应用。

## 20220102，合并两个有序链表

[leetcode链接](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

*关键词* ：无

简单得不知道怎么说。

## 20220103，最大子数组和

[leetcode链接](https://leetcode-cn.com/problems/maximum-subarray/)

*关键词* ：前缀和，动态规划

自己做的时候是用的前缀和的做法，答案用的是动态规划的做法，复杂度上来说都是一样的，不过动态规划确实直接一点，不过转移方程可能会有一点点不好想。从之前做过的题来看，前缀和的做法主要应用于求连续子数组/子路径等的个数，在这里不是完全适用，不过原理也算相通。这里用的是很简单的版本，只是记录着到目前为止遍历到的最小的前缀和。

## 20220104，爬楼梯

[leetcode链接](https://leetcode-cn.com/problems/climbing-stairs/)

*关键词* ：动态规划，快速幂

基础的动态规划题目，由于是线性递推公式，所以也可以用矩阵快速幂解决，把时间复杂度降到O(log(n))。矩阵快速幂是一种之前没有了解过的方法，这种思想很值得学习。
