# Leetcode刷题笔记

[toc]

## 20211206，除自身以外数组的乘积

[leetcode链接](https://leetcode-cn.com/problems/product-of-array-except-self/)

*关键词* : 双向遍历

做过的题目，从两头各遍历一次，第一次做很难做出来，做过一次后再遇到就容易想到了。

## 20211207，搜索二维矩阵

[leetcode链接](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

*关键词* ：二维数组

也是做过的题，第一次做的时候理解还不深刻，没有意识到自己的解法的问题所在。自己的做法是根据中心点与目标值大小的比较把整个矩阵分成4块，然后可以根据比较结果丢掉一块，分别对剩余三块进行递归，以为这样时间复杂度就是O(log(mn))，实际上不是，见下图：

```text
                                               n
                                                    
                                                    
             n/4                              n/4                               n/4
                  
                                                                                                  log4(mn)层
                  
n/16         n/16        n/16    n/16          n/16         n/16      n/16        n/16      n/16
     
     
     ..................................................................................................
```

最底层总共有3^log4(mn)^ =(mn)^log4(3)^ 个元素，因此根据等比数列求和公式，总的时间复杂度还是O((mn)^log4(3)^)，很接近O(mn)，并不是想的O(log(mn))。而答案的做法则是很巧妙地从右上角开始，每进行一次比较就丢弃掉一行或者一列，时间复杂度达到O(m+n)，代码也很简洁。

## 20211208，完全平方数

[leetcode链接](https://leetcode-cn.com/problems/perfect-squares/)

*关键词* ：动态规划，数学题

动态规划题，一开始还是用的有记忆的递归做的，理论上时间复杂度应该是一样的，但是实际上递归会慢很多，以后遇到这种题就不需要犹豫，直接动态规划就好了。另外答案还给了数学方法的解法，大大降低时间复杂度。但是用到的数学原理实在是太专业了，非数学相关专业一般接触不到的做法，所以也挺无聊的。

## 20211209，寻找重复数

[leetcode链接](https://leetcode-cn.com/problems/find-the-duplicate-number/)

*关键词* ：二分法，位运算，Floyd判圈算法

要满足空间复杂度为O(1)，难度挺大的题。如果时间复杂度为O(nlog(n))，可以采用二分法与位运算的做法，进一步将时间复杂度提高到O(n)，就只有采用Floyd判圈算法。这三种做法思路都非常巧妙，下面分别进行分析。

1. 二分法

    根据数组中比`i`小的元素数量`count[i]`的大小与`i`的大小关系来判断`i`是比要找的数大还是小，从而把`[1, n]`分成两半，对目标所在的一半继续进行递归操作，直到找到目标值。有个细节需要注意，就是用来存储结果的变量`result`的更新的问题，由于`result`肯定是在`count[i] > i`的部分，因此只有进入到这一部分时，才需要将`result`更新为当前的`middle`变量的值，进入另一部分时只需要更新范围，不需要更新结果变量。

2. 位运算

    自己做的时候想过位运算方向的解法，可惜没想明白。这种做法是逐位求出目标值，巧妙点在于对每一位，对比数组`nums`中该位置为`1`的元素的数量，将其与数组`[1, n]`中该位置为`1`的元素数量对比，若前者大，则说明目标值该位置为`1`，否则为`0`，利用这个原理，就能很容易地做出这题。

3. Floyd判圈算法

    最快的做法，时间复杂度达到了O(n)，但我感觉也是没看过答案绝对做不出的方法。这种做法把数组看作一个有向图的`n + 1`条边，分别表示由`i`指向`nums[i]`，`n + 1`个节点共有`n + 1`条边，而且必有一个节点入度为`2`以上，因此该有向图必存在一个圈，且入圈的节点就是入度为`2`的节点，也就是我们要找的重复数，这个问题就变成了寻找环形链表的入环节点的问题，就可以用时间复杂度为O(n)的Floyd判圈算法解决该问题。

## 20211210，最长递增子序列

[leetcode链接](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

*关键词* ：二分法，动态规划，改进动态规划

O(n^2^)时间复杂度的解法不难实现，普通的动态规划就可以，而O(nlog(n))时间复杂度的解法就很困难了。前者选取的状态变量为以元素`nums[i]`结尾的最长递增子序列，而后者则完全换了方法，选取长度为`l`的最长递增子序列的结尾元素作为状态变量，并在遍历的过程中对状态变量数组进行更新，这种情况下的状态变量数组是有序的，因此就可以采用二分查找，把时间复杂度降下来。这种题至少需要大量的积累才有可能能有最优解法的思路，还需努力。

## 20211211，最佳买卖股票时机含冷冻期

[leetcode链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

*关键词* ：动态规划，空间优化动态规划

比较难的动态规划问题。选取的状态变量是能比较容易想到的第`i`天结束后的最大收益，不过困难的是这个状态变量又分成了三种情况，分别是第`i`天结束后持有股票，未持有股票并处于冷冻期和未持有股票而且不处于冷冻期，根据第`i - 1`天这三种情况下的状态就可以推出第`i`天的状态。最后只需要求出最后一天两种不持有股票情况下的最大值就可以得出答案。综合来看状态变量的选取以及转移方程都比较难想，还需要更多积累才能做好这道题。

## 20211212，零钱兑换

[leetcode链接](https://leetcode-cn.com/problems/coin-change/)

*关键词* ：动态规划

基本上是最基础的不能进行空间优化的动态规划了，和前几天做的[完全平方数的题](##20211208，完全平方数)的动态规划解法差不多。

## 20211213，打家劫舍III

[leetcode链接](https://leetcode-cn.com/problems/house-robber-iii/)

*关键词* ：记忆递归，动态规划，空间优化动态规划，深度优先搜索(DFS)

把动态规划搬到了二叉树结构，与普通动态规划区别只是在于将普通数组换成了哈希表。由于对二叉树的深度优先遍历本身就要用到递归栈，因此本题用带记忆的递归也可以做，本质上是一样的，就是动态规划是后序遍历，而记忆递归某种程度上算是先序遍历。不过动态规划可以进行空间优化，由于对于每个节点的分析只需要用到它的两个子节点的结果，因此可以去掉哈希表。

## 20211214，前K个高频元素

[leetcode链接](https://leetcode-cn.com/problems/top-k-frequent-elements/)

*关键词* ：堆，快速排序

可以用大根堆做，也可以用小根堆做，大根堆就是把所有元素放进堆中，然后取出前K个放进数组，这种情况下的时间复杂度是O(nlog(n))，而小根堆则是将容量限制为K，维护前K个出现频率最高的元素，这种情况下的时间复杂度是O(nlog(k))，所以理论上来说小根堆更好一些。另一种做法是利用快排的原理，每次确定一个元素的位置，直到确定的元素位置恰好为K时，即可确定前K个高频元素，这种解法理论上的时间复杂度可以降低到O(n)。

## 20211215，字符串解码

[leetcode链接](https://leetcode-cn.com/problems/decode-string/)

*关键词* ：栈，递归

辅助栈的做法和递归的做法差不多。这种题说难也不难，但是麻烦是真麻烦，要把代码写得简洁更麻烦，不知道笔试面试喜欢不喜欢考这种题。

## 20211216，除法求值（待解决）

[leetcode链接](https://leetcode-cn.com/problems/evaluate-division/)

*关键词* ：加权并查集

很难啊，先留一留，后面慢慢看。

## 20211217，根据身高重建队列

[leetcode链接](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

*关键词* ：排序

想法不算很难的一道题。有个细节需要注意，就是排序的时候可以优先通过身高排序，然后根据第二项也就是身前有多少人进行逆序排序，这样就可以避免另外处理身高相同的情况，这个想法很值得学习。另外让我不太明白的一点在于从低到高排序然后通过数`null`来插入数组的做法为什么会比从高到低排序然后插入列表然后转化为数组的做法慢这么多，能想到的可能的原因在于第一种方法耗费的时间大约是n^2^，而第二种方法耗费的时间大约是n^2^/2，或者还是说Java的ArrayList的插入有优化？不理解。

## 20211218，分割等和子集

[leetcode链接](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

*关键词* ：动态规划，空间优化动态规划，高时间复杂度，背包问题

挺难的题，主要在于这种动态规划方法不好想，无论是状态变量还是转移方程，而且这道题的时间复杂度还很高，显得更吓人了。而且答案中从普通动态规划转向空间优化的动态规划过程中有一些细节需要注意。

## 20211219，路径总和III

[leetcode链接](https://leetcode-cn.com/problems/path-sum-iii/)

*关键词* ：深度优先搜索(DFS)，空间换时间，前缀和

也不算简单的题，暴力一点是要分别从每个节点开始向下搜索，时间复杂度为O(n^2^)，而这道题的解法则很巧妙地用了前缀和的做法，这样就可以利用空间换时间的思想，建立一个哈希表，把内部循环改成时间复杂度为常数的哈希表查询，从而将时间复杂度降为O(n)。前缀和的采用是本题的关键。

## 20211220，找到字符串中所有字母异位词

[leetcode链接](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

*关键词* ：滑动窗口

普通的滑动窗口的方法很容易想到，但是时间复杂度较高，本题答案的关键步骤就在于对检测字母异位词的过程的优化，采用一个记录当前字符串与目标字符串不同数目的字母的个数的变量以及一个记录各字母数目差别的数组，每次移动窗口只需要访问两个位置来维护这个变量，把时间复杂度降了下来。类似的时间复杂度降低的需求还是挺多的，不过解决方法似乎不尽相同。

## 20211221，目标和

[leetcode链接](https://leetcode-cn.com/problems/target-sum/)

*关键词* ：动态规划，空间优化动态规划，高时间复杂度，背包问题

和前几天的[那道题](##20211218，分割等和子集)差不多的题，都属于背包问题，解决方法也类似，唯一的区别在于那道题是找没有，而这道题是找有多少种。有个细节需要注意，以空间优化前的做法为例，需要建立一行辅助行，用于表示有0个元素可选时能组成各数的选法数目，前几天的题没有这一行是没关系的，可以通过对第一行多做一些处理来等效，但是今天这道题在`[0, 0, 0, 0, 0, 1]`这类输入时就会出现问题。

## 20211222，把二叉搜索树转换为累加树

[leetcode链接](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

*关键词* ：深度优先搜素(DFS)，Morris遍历

普通的中序遍历做法很容易，不过空间复杂度较高，递归占的空间为O(n)。比较有趣的做法是Morris遍历做法，这种方法把空间复杂度降到了O(1)，但是其消耗的时间稍微长一点，但是渐进复杂度还是O(n)，答案复杂度分析好像有点问题，好像应该是没有右子树的节点会访问一次，而有右子树的节点会访问两次。这种做法很巧妙，类似于利用二叉树的叶子节点的闲置指针把二叉树展开为中序遍历的顺序的链表，而且时间复杂度还是与节点个数成正比的线性复杂度，很值得多思考的方法，以后遇到二叉树的问题也可以多尝试这种方法。

## 20211223，和为K的子数组

[leetcode链接](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

*关键词* ：前缀和

和前几天的[那道题](##20211219，路径总和III)差不多的做法，那道题是在树上应用了前缀和的做法，而这道题是在数组上应用前缀和的做法，这道题还相对简单一点。从这两道题可以总结出的经验是前缀和的做法基本都应用于**连续**的和，可以把时间复杂度从其他做法的O(n^2^)降到O(n)，不过要额外占用O(n)的空间复杂度。

## 20211224，最短无序连续子数组

[leetcode链接](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

*关键词* ：排序，逆序对

从逆序对的角度来考虑好理解一点。要把数组分成三部分，只要把中间部分排序那么整个数组就是有序的，所以所有的逆序对都必须落在中间部分，要找中间部分的边界，就要找所有逆序对中最左边的边界与最右边的边界。以寻找右边界为例分析一下，自己的做法是新建一个数组，首先从左到右遍历，记录每个位置之前的最大值，得到一个最大值数组，然后从右往左遍历，对比原数组与最大值数组的不同，第一个不同的位置就说明这个位置之前有个比他更大的元素，说明这个就是所有逆序对的右边界；而答案的做法则是在从左向右遍历的同时用一个变量记录到目前为止的最大值，并用一个变量来维护右边界的位置，当遍历到的位置比最大值小时，说明这个位置是某个逆序对的右边，遍历一遍后就能找到所有逆序对最右边的边界。自己的做法需要遍历两次，而且需要一个额外的数组存放最大值，而答案的方法只需要遍历一次，而且只需要常数级的空间，所以显然答案的方法更优。

## 20211225，任务调度器

[leetcode链接](https://leetcode-cn.com/problems/task-scheduler/)

*关键词* ：数学题

不好说这是什么解法，自己想的时候太执着于排序之后再做了，而且没考虑明白字母种类比n大的情况，也是考虑思路错了。按答案写的解法不算太快，比较快的解法是用长为26的数组代替哈希表，这一点值得注意。

## 20211226，回文子串

[leetcode链接](https://leetcode-cn.com/problems/task-scheduler/)

*关键词* ：Manacher算法

一开始看到这题就想用动态规划做，倒是也能做，但是时间复杂度高达O(n^2^)，空间复杂度也有O(n)，都算不上好。答案给出的第一种遍历所有回文子串的可能的中心，然后向两边扩展的方法时间复杂度也是O(n^2^)，而且只使用了常数的空间。关于这个解法需要注意的奇数长度回文串与偶数长度回文串的结合方法，通过遍历包括字母位置与字母之间的位置共`2n-1`个中心，把两种情况合到一个循环里。而答案的第二种做法，也就是Manacher算法，把时间复杂度压到了O(n)。这种算法通过在从左向右遍历的过程中记录一个到目前为止的回文子串所能到达的最右边的位置，结合前面已经计算过的与以这个最右边位置对应的回文子串中心对称的点的回文子串的长度，避免一定的重复计算。不过现在确实对这个算法理解不够深刻，还要多回来复习复习。

## 20211227，每日温度

[leetcode链接](https://leetcode-cn.com/problems/daily-temperatures/)

*关键词* ：单调栈

自己的做法算是动态规划从右向左遍历温度数组，对于遍历到的元素，通过其右边的元素的状态来确定其状态，若右边元素比该元素大，则待求位置的结果就是1，否则，再判断右边位置的天数是不是0，如果是的话那么可以直接给当前位置赋0，否则就找到右边位置的结果对应的位置，重复上述过程。这种做法比较宽松的一个时间复杂度上限是O(n^2^)，但是暂时还不知道准确的时间复杂度该是多少。答案用的单调栈的方法，时间复杂度为O(n)，是很合理的做法，但是什么情况下要用单调栈的做法还需要多归纳。

## 20211228，两数相加

[leetcode链接](https://leetcode-cn.com/problems/add-two-numbers/)

*关键词* ：链表

挺普通的题。个人感觉这题最大的意义在于锻炼提高代码简洁度的水平。

## 20211229，无重复字符的最长字串

[leetcode链接](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

*关键词* ：滑动窗口

自己想的办法实际上跟答案差不多，都可以用滑动窗口来理解。就是自己的方法一开始用了一个队列比较多余，可以直接双指针解决的。可以优化的点在于用128位的数组代替哈希表。

## 20211230，全排列

[leetcode链接](https://leetcode-cn.com/problems/permutations/)

*关键词* ：回溯

普通的DFS回溯算法，答案做法相比于自己的做法优化了空间复杂度，通过在原数组直接修改避免了用一个额外的标记数组或者用个链表来标记遍历过的数组元素。

## 20211231，两数之和

[leetcode链接](https://leetcode-cn.com/problems/two-sum/)

*关键词* ：哈希

普通的哈希表的应用。

## 20220101，有效的括号

[leetcode链接](https://leetcode-cn.com/problems/valid-parentheses/)

*关键词* ：辅助栈

辅助栈的简单应用。

## 20220102，合并两个有序链表

[leetcode链接](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

*关键词* ：无

简单得不知道怎么说。

## 20220103，最大子数组和

[leetcode链接](https://leetcode-cn.com/problems/maximum-subarray/)

*关键词* ：前缀和，动态规划

自己做的时候是用的前缀和的做法，答案用的是动态规划的做法，复杂度上来说都是一样的，不过动态规划确实直接一点，不过转移方程可能会有一点点不好想。从之前做过的题来看，前缀和的做法主要应用于求连续子数组/子路径等的个数，在这里不是完全适用，不过原理也算相通。这里用的是很简单的版本，只是记录着到目前为止遍历到的最小的前缀和。

## 20220104，爬楼梯

[leetcode链接](https://leetcode-cn.com/problems/climbing-stairs/)

*关键词* ：动态规划，快速幂

基础的动态规划题目，由于是线性递推公式，所以也可以用矩阵快速幂解决，把时间复杂度降到O(log(n))。矩阵快速幂是一种之前没有了解过的方法，这种思想很值得学习。

## 20220105，对称二叉树

[leetcode链接](https://leetcode-cn.com/problems/symmetric-tree/)

*关键词* ：递归

有递归和迭代两种做法，递归显而易见，没什么需要说的。至于迭代，可以广度优先迭代也可以深度优先迭代，建立一个队列或者一个栈，每次进队出队或者进栈出栈一对元素，实际上也很容易理解。

## 20220106，二叉树的中序遍历

[leetcode链接](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

*关键词* ：中序遍历，Morris遍历

基本的中序遍历，有递归、迭代和Morris遍历三种做法。递归不用说；迭代的做法用来实现先序遍历比较容易，但是也可以用来实现中序遍历，不过操作比较麻烦，以后要多熟悉一下；Morris遍历在之前写过一次，其实也不是很难，多熟悉熟悉思路应该不会被难住。

## 20220107，二叉树的最大深度

[leetcode链接](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

*关键词* ：BFS

可以递归，也可以宽度优先搜索，看上去递归更快一点。注意，是递归，不是DFS。

## 20220108，买卖股票的最佳时机

[leetcode链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

*关键词* ：无

买卖股票系列最简单的题，不过不同于同系列其他题需要用到二维动态规划，本题只需要记录最小值，不具有太大参考价值。

## 20220109，只出现一次的数字

[leetcode链接](https://leetcode-cn.com/problems/single-number/)

*关键词* ：位运算

利用相同的数字按位异或后结果为0的特点，将整个数组逐个进行异或运算，得到的结果就是唯一的只有一个的数字。位运算的意识和对这种异或特性的敏感性是做这道题的关键点，不常用位运算而且是第一次做这题的话几乎不可能会，但是做过一次之后也就不难想到了。

## 20220110，环形链表

[leetcode链接](https://leetcode-cn.com/problems/linked-list-cycle/)

*关键词* ：快慢指针，Floyd判圈算法

基础的Floyd判圈算法应用，但是还没有让求进环节点。

## 20220111，最小栈

[leetcode链接](https://leetcode-cn.com/problems/min-stack/)

*关键词* ：无

用一个辅助栈保存到目前为止的最小值，比较容易的思路。

## 20220112，相交链表

[leetcode链接](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

*关键词* ：无

两个指针分别从各自头节点出发，走完当前链表再去走另一个链表，直到两个指针相等，即指向相交节点或者都为`null`，也是属于没做过很难想到，但是做过一遍就完全没难度的题。

## 20220113，多数元素

[leetcode链接](https://leetcode-cn.com/problems/majority-element/)

*关键词* ：摩尔投票法

摩尔投票法概念的引出，如果熟悉这个思想的话这题并不难。

## 20220114，反转链表

[leetcode链接](https://leetcode-cn.com/problems/reverse-linked-list/)

*关键词* ：双指针

双指针同时前进，遍历一遍即可。需要注意的是可以将给出的`head`头指针为`null`的情况与其他情况合在一起。

## 20220115，翻转二叉树

[leetcode链接](https://leetcode-cn.com/problems/invert-binary-tree/)

*关键词* ：无

基础递归。

## 20220116，回文链表

[leetcode链接](https://leetcode-cn.com/problems/palindrome-linked-list/)

*关键词* ：无

不太好想的一个思路，判断链表的回文是通过先找到中间点，在切下右半部分，然后利用[反转链表](##20220114，反转链表)的方法将右半部分反转，再与左半部分比较，实现并不难，也没有什么特别刁钻的方法，不过第一遍做要想到这种做法还是要花点时间的。

## 20220117，移动零

[leetcode链接](https://leetcode-cn.com/problems/move-zeroes/)

*关键词* ：双指针

一种自己想的方法是遍历一遍，记录数组中所有0的位置，然后再遍历一遍，根据已知的0的位置移动元素，这样要遍历两遍，而且空间复杂度为O(n)，而双指针的做法可以只遍历一遍，而且空间复杂度为O(1)。另一个值得学习的点在于答案中双指针部分外层大遍历和内层小遍历的结合方式，一种比较优雅的写法。

## 20220118，比特位计数

[leetcode链接](https://leetcode-cn.com/problems/counting-bits/)

*关键词* ：位运算，Brian Kernighan 算法

动态规划+位运算的方法。很明显的动态规划题目，位运算部分比较有意思。基础的把当前元素除2并结合奇偶判断不算太难想。其他方法都用到了Brian Kernighan 算法，其思想是`i & (i - 1)`这个表达式可以消掉二进制形式的`i`的最后一个`1`，这个思想很关键，引申出很多计算当前元素二进制去掉一个`1`的方法，而且感觉也可以在其他很多位运算的题目中应用，需要多多注意。

## 20220119，找到所有数组中消失的数字

[leetcode链接](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

*关键词* ：无

要在不使用哈希表和同样效果的标记数组的情况下，就要利用原数组中每个元素都在`1`和`n`之间的性质，改变原数组，把原数组当作哈希表用。自己的做法是把遍历到的元素对应数组位置改成`-1`，再把那个位置的元素移动到当前位置，再次进行判断，直到当前位置为`-1`。这种做法可行，但是比较麻烦。答案用的做法是遍历到的元素对应数组位置加`n`，从而后面遍历的时候可以通过取余来取出数组元素，这样可以在保留原数组全部信息的同时达到标记的目的。在不需要考虑整数溢出的情况下是很好的方法。

## 20220120，汉明距离

[leetcode链接](https://leetcode-cn.com/problems/hamming-distance/)

*关键词* ：位运算，Brian Kernighan 算法

又用到了Brian Kernighan 算法，这种算法虽然不足以降低时间复杂度，但是可以避免很多不必要的运算。

## 20220121，二叉树的直径

[leetcode链接](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

*关键词* ：DFS，后序遍历

通过后序遍历计算以每个节点为中心的两个树枝的最大深度，加起来得到该节点的最大直径。遍历过程中需要记录的包括节点深度以及目前遍历到的最大直径。自己的做法是把直径当作递归函数返回值，然后用一个哈希表记录各节点深度，而答案是把直径放到全局变量，把深度当作递归函数返回值，这样做节省了哈希表的空间，但是需要一个全局变量。尝试了一下用迭代的方式避免全局变量的使用，好像不太容易。

## 20220122，合并二叉树

[leetcode链接](https://leetcode-cn.com/problems/merge-two-binary-trees/)

*关键词* ：DFS

递归深度优先遍历即可很容易地解决。广度优先遍历原理也不是太难，但是代码更复杂，有点多此一举的感觉。

## 20220123，合并K个升序链表

[leetcode链接](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

*关键词* ：堆

很简单的一道困难题。思路有两个，一个是每次处理一半，然后将结果合并，递归此操作；另一个是引入一个堆，每次取出堆顶上的一个元素加入结果链表。两种做法的时间复杂度都是O(n*log(k))，其中`n`是所有链表的节点总个数，`k`是链表个数。

## 20220124，最长有效括号

[leetcode链接](https://leetcode-cn.com/problems/longest-valid-parentheses/)

*关键词* ：动态规划，栈

三种做法，都说不上太难理解。其中动态规划的做法比较容易想到，借助辅助栈的做法和用两个变量分别计数左括号和右括号的做法都是利用了从某个右括号开始计数，每次达到左右括号数量相等的时候就计算一下此时的有效序列长度，当右括号更多的时候就重新开始计数。其中用两个变量分别计数的方法需要考虑左括号一直比右括号多的情况，解决方法是再反向遍历一遍。这种做法的空间复杂度是O(1)，是最佳的做法。

## 20220125，接雨水

[leetcode链接](https://leetcode-cn.com/problems/trapping-rain-water/)

*关键词* ：单调栈，双指针

三种做法。最近的困难题都死这种，有几个比较容易想到的做法，但时间空间复杂度都不是最优，最佳方法需要花一些功夫。在这个题里面，正反两次遍历，并用一个额外的数组存储一个方向的遍历结果的解法比较容易想到，但是空间复杂度为O(n)，而且要遍历两次；单调栈的做法是保存从栈底到栈顶递减的栈，遍历到一个比栈顶元素高的柱子时，就弹出栈顶元素，并计算由当前元素，弹出的元素以及弹出之后的栈顶元素构成的洼地的体积，加到结果里面，这种做法只要遍历一次，但是栈要占用额外的O(n)的空间复杂度；最佳的双指针做法理解起来有点困难，能想到就更困难了，这个题的核心思想在于每个列能容纳的雨水由其左边的最高的柱子和其右边的最高的柱子决定，两次遍历的做法就是分别求这两个值，而双指针的做法则巧妙地只用一个边界计算每一列的水，实现这种情况的前提就是用来确定高度的边界一定是比较小的那个边界，本解法用双指针实现了这个前提，不同于朝一个方向的顺序遍历，双指针解法利用两个指针进行由两侧向中间的遍历，实现所用的边界是较小的边界的关键就在于，每次都处理并移动当前高度较小的指针，这样做就确保了处理某一侧的时候，另一侧一定存在遍历到的某个柱子比本侧所有柱子都高，否则，假如本侧有更高的柱子的话，那么就不会处理并移动本侧的指针了，出现矛盾，因此这种做法是正确的。特别需要注意与学习双指针的做法。

## 20220126，正则表达式匹配

[leetcode链接](https://leetcode-cn.com/problems/regular-expression-matching/)

*关键词* ：动态规划

一开始没想到能用动态规划做，而且一直很自然地在想时间复杂度O(m+n)的做法，也就是同时遍历两个字符串，挨个匹配，但是真正写起来十分复杂，问题很多。相比之下动态规划的做法就聪明很多，但是时间与空间复杂度也上升到了O(mn)，不知道有没有人能写出O(m+n)的解法。动态规划的状态变量选为字符串`s`的前`i`个元素与字符串`p`的前`j`个元素能否匹配，这一点不容易想到，想到这一点之后，剩下的难点就在于遍历到字符串`p`的`*`时如何解决的问题，这实际上也是在写直接遍历匹配两个字符串时遇到的主要困难，这里动态规划的解决方法也是很巧妙，将重复`0`次与重复`n`次分开处理，重复`0`次就直接跳过，重复`n`次就把`s`字符串指针向前移一位对应的`dp`数组的结果取过来，这种做法更难想到，而且也不好理解，但是想到之后就能使代码变得非常简洁明了。

## 20220207，编辑距离

[leetcode链接](https://leetcode-cn.com/problems/edit-distance/)

*关键词* ：动态规划

困难难度的题好像很喜欢动态规划啊。这题确实是很难，选取word1的前i个字符和word2的前j个字符之间的编辑距离作为状态变量，这一点很难想到，递推则是用`dp[i][j-1]`、`dp[i-1][j]`和`dp[i-1][j-1]`三项来推出`dp[i][j]`的值。说起来也是普通的动态规划做法，但是自己做的时候面对着既能插入，又能删除，还能替换这么灵活的操作有点不知所措了，也不够大胆，没能分析出动态规划的做法。

## 20220208，最小覆盖子串

[leetcode链接](https://leetcode-cn.com/problems/minimum-window-substring/)

*关键词* ：滑动窗口，双指针

单纯的滑动窗口解法也不复杂，但是可能是因为自己滑动窗口的题目做的太少，没有想到怎么做。这里的窗口是一个变长的窗口，所以说与其叫滑动窗口，不如叫双指针。一开始做这道题的时候一直在想类似于之前[路径总和](##20211219，路径总和III)那道题的做法，也就是前缀和，不过在这里不太适用。滑动窗口做法的优化是另一个需要关注的点，这个做法中有很多地方需要比较当前某个子串是否包含目标字符串，如果用哈希表逐个字符对比的话，那么一次比较的时间复杂度就是O(C)，这里C是目标字符串中的字符种类数，但是优化做法可以用一个`count`变量来记录当前子串中对应目标字符串中各种字符的数目总和，其中数目超过目标字符串的则记目标字符串中该字符的数量，这样就可以用这一个变量来判断当前子串是否包含目标字符串，把这个过程的时间复杂度降到O(1)。

## 20220209，柱状图中的最大矩形

[leetcode链接](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

*关键词* ：单调栈

虽然没做出来，不过还是有那么一点成就感的。一开始想的动态规划和单调栈两种做法，排除了动态规划，单调栈的主要思路和答案一样，但是没有考虑到可以按每个位置的柱子高度作为矩形高度进行遍历，也就是没有想到时间复杂度为O(n^2^)的暴力做法，也就没办法用单调栈进行改进。单调栈的题目做得还是少，需要更多练习。另外一个需要注意的点在于新元素进栈时把栈中比新元素高度高的元素全部出栈，这一步对于高度相等的元素如何处理，其实不需要管，因为并不需要每个都准确求出，只需要求出最大值就好，不管怎么处理高度相等的柱子，都会有一个边界求出这个高度的最大矩形，这对于这道题来说也就够了。还有一个是数据结构的使用的问题，对于栈的实现数据结构，如果用`Stack`类的话执行时间约为`130ms`，同样的程序，换成`Deque`实现栈之后执行时间就只剩了`20ms`，虽然不知道为什么差距这么大，但是以后做题的时候如果要追求尽可能短的实际执行时间的话还是用`Deque`比较好。

## 20220210，最大矩形

[leetcode链接](https://leetcode-cn.com/problems/maximal-rectangle/)

*关键词* ：单调栈

这个是真的没想到能这么做，隐约记得好像之前做过这题，现在看来是记错了。一开始一直在想动态规划的做法，状态变量选为以每个位置为右下角的最大矩形，但是很难找到合适的递推关系。在想着简化暴力做法的时候也想到过先遍历一遍，求出每个位置以左/以上的连续`1`的个数，但是没有进一步和[柱状图中的最大矩形](##20220209，柱状图中的最大矩形)这题联系到一起，这一步最难想，但是如果能想通的话这题也就迎刃而解了，如果说有什么启发的话那就是尽可能把不会的题归类到之前用过的解法上，完全没见过的类型本身也很难做出来了。

## 20220211，二叉树中的最大路径和

[leetcode链接](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

*关键词* ：深度优先搜索(DFS)

很简单的一道困难题，顶多中等难度水平。需要讨论的一点是类成员变量的使用，在这里类成员变量相当于全局变量，在这道题中，辅助`DFS`方法需要同时记录两个变量，分别是到当前为止的最大路径和以及以当前节点为结尾的分支的最大和，但是方法只能有一个返回值，因此另一个值只能以类成员变量的形式存在，很多答案题解中并没有刻意避免成员变量的使用，所以以后如果遇到类似的方法需要两个返回值，而且引入成员变量后可以大幅简化的情况还是可以用的。

## 20220212，滑动窗口最大值

[leetcode链接](https://leetcode-cn.com/problems/sliding-window-maximum/)

*关键词* ：单调队列，分块预处理

从题解来看不是一道很难的题，而且还做过一遍，但是还是没想出来该怎么做。单调队列或者单调栈的思路总是和最值问题练习在一起，另外的分块预处理的做法是第一次见，很有意思，很新颖。总的来说通过这题还是要多反思为什么没有想到单调队列的做法，以及学习分块预处理的做法。

## 20220213，删除无效的括号

[leetcode链接](https://leetcode-cn.com/problems/remove-invalid-parentheses/)

*关键词* ：回溯

答案的做法比自己想的暴力得多，回溯的做法从思路上来说不算太困难，不过要考虑一下剪枝的策略。广度优先的做法就更不用说了，更暴力，不过也因为太暴力了不容易想到。从思路上来说称得上是困难的就是状态枚举子集的做法了，这种做法分别处理左括号与右括号，根据需要删除的总的左括号数与右括号数，枚举所有可能的删除可能，然后将左括号与右括号的删除结果进行组合，验证正确性，需要注意的是，在这个过程中，枚举的删除可能性是通过一个整数模拟的，对于该整数的各位，若为`1`，则该位置删除，否则不删除，从而可用`Integer`类的`bitcount(int i)`方法计数删除个数，初步筛选。

## 20220214，戳气球

[leetcode链接](https://leetcode-cn.com/problems/burst-balloons/)

*关键词* ：动态规划

这道题，暴力解法的时间复杂度是O(n!)，为了简化，不难想到可以借助动态规划的方法。动态规划的核心思想在于复用某部分的计算结果，但是在原来的戳气球的背景下，复用的方法难以想到。答案比较巧妙地从后往前处理，把戳气球的问题变成了挂气球的问题，这样就可以达到复用计算结果的目的。回过头来看，动态规划必然是从较为简单的情况开始处理，而在这道题中，一开始挂满气球的情况是最复杂的情况，而只剩一个气球的情况则是最简单的情况，因此把戳气球问题转化成挂气球问题也是顺理成章的问题。所以，以后遇到类似这种似是而非的动态规划的问题，有两件事需要思考，第一个是最简单的情况是怎样的，找到最简单的情况后就从这个位置开始处理；第二个是怎样才能复用计算结果，或者可以在脑内模拟一下暴力做法的计算过程，想一想哪些计算是重复的。听上去上面这些全是废话，好像这些都是动态规划所必备的，可能还是自己对动态规划的理解不够深刻，还需要多做题，多训练。

## 20220215，寻找两个正序数组的中位数

[leetcode链接](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

*关键词* ：二分查找

这道题主题思路也算是说难也不太难，但是非常麻烦，有非常多的细节需要考虑。第二种做法利用了一点数学公式的推导，思路比较新颖，需要多看一看。细节方面的东西感觉只能多做题多总结。

## 20220216，节点间通路

[leetcode链接](https://leetcode-cn.com/problems/route-between-nodes-lcci/)

*关键词* ：图，DFS，BFS

最最基础的图论题目，BFS和DFS都可以做。

## 20220217，二分查找

[leetcode链接](https://leetcode-cn.com/problems/binary-search/)

*关键词* ：二分查找

基础二分查找，关键在于区间边界是否包含(`right = nums.length` 或 `right = nums.length - 1`)，循环比较是否取等(`left < right` 或 `left <= right`)，以及移动右边界的位置(`right = middle` 或 `right = middle + 1`)这三个问题，实际只有两种情况，需要明确。

## 20220218，移除元素

[leetcode链接](https://leetcode-cn.com/problems/remove-element/)

*关键词* ：双指针

应该也是之前做过的题目，记得之前做的时候还想着计算每个元素该移动的长度，把问题想得过于复杂了，相对来说双指针做法很直观，后面专门练习双指针的时候可以再总结。这道题的优化双指针解法比较有意思，不过这么做的前提是题目对结果的元素顺序没有要求。

## 20220219，有序数组的平方

[leetcode链接](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

*关键词* ：双指针

题目不难，不过比较直观的是想找到中间的0点，并从0点开始向两边遍历，来从左向右填充平方数组，但是稍微拐一点弯就有一个更简单的方法，那就是从两边向中间遍历，从右向左填充平方数组，省掉了寻找0点的操作。

## 20220220，长度最小的子数组

[leetcode链接](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

*关键词* ：前缀和，滑动窗口

好像大家都能想到滑动窗口的做法，但是没想到前缀和的做法，但是在我这正好反过来，看到**连续**这两个字就想用前缀和的方法做，但是前缀和的做法边界问题需要花一定的精力去考虑，或者说是去试，而且滑动窗口的复杂度是绝对优于前缀和的，这么想想滑动窗口真是很神奇的做法，用两个指针遍历两遍就达到了暴力做法的效果，之前对这种做法思考较少，需要多留意，以后遇见**连续**关键词，尤其是数组中的连续，除了前缀和之外也要想想滑动窗口能不能发挥作用。

## 20220221，螺旋矩阵II

[leetcode链接](https://leetcode-cn.com/problems/spiral-matrix-ii/)

*关键词* ：无

就是模拟整个过程，需要考虑边界问题。

## 20220222，移除链表元素

[leetcode链接](https://leetcode-cn.com/problems/remove-linked-list-elements/)

*关键词* ：双指针

普通的链表双指针，注意虚拟头节点，也就是`sentinel`节点的运用，可以使代码更加优雅。

## 20220223，设计链表

[leetcode链接](https://leetcode-cn.com/problems/design-linked-list/)

*关键词* ：无

普通的设计类的题目，注意哨兵头节点的应用。

## 20220224，两两交换链表中的节点

[leetcode链接](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

*关键词* ：双指针

普通的链表双指针题目，同样注意哨兵节点的应用。

## 20220225，删除链表的倒数第N个节点

[leetcode链接](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

*关键词* ：双指针

普通双指针，还是要注意哨兵节点的使用，尤其是要删除的节点是头结点的时候。

## 20220226，链表相交

[leetcode链接](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

*关键词* ：双指针

这个第一次做的话能想到双指针非常不容易，但是做过一遍之后就没有什么难处了，还是要好好想一些小细节，不然会非常难受。

## 20220227，环形链表II

[leetcode链接](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

*关键词* ：快慢指针，Floyd判圈法

快慢指针做法，还是第一次做的话基本不可能做得出来，但是做过一两遍之后就容易了。哨兵节点仍然很好用，虽然答案没有用到，但是自己用起来还是能简化很多思考。

## 20220228，有效的字母异位词

[leetcode链接](https://leetcode-cn.com/problems/valid-anagram/)

*关键词* ：哈希表

基础的哈希思想。

## 20220301，两个数组的交集

[leetcode链接](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

*关键词* ：哈希表

这题有点刻意了，难度并不大。不过排序然后双指针的解法还是比较有意思的，值得学习。

## 20220302，快乐数

[leetcode链接](https://leetcode-cn.com/problems/happy-number/)

*关键词* ：哈希表，Floyd判圈法

哈希表的做法非常显而易见，但是还能用Floyd判圈法是没想到的，不过想想确实也是合理的，这样直接把空间复杂度降到了O(1)。Floyd判圈法的应用十分广泛，在涉及到环类问题的时候可以多往这方面考虑。

## 20220303，两数之和

[leetcode链接](https://leetcode-cn.com/problems/two-sum/)

*关键词* ：哈希表

哈希表的简单应用。需要注意的是答案的方法能一次遍历解决问题，没有必要先遍历一遍存个`Map`，再遍历一遍挨个寻找元素，一次遍历边存边找就能解决问题了。

## 20220304，四数相加II

[leetcode链接](https://leetcode-cn.com/problems/4sum-ii/)

*关键词* ：哈希表

把四个数组平分为两组，之后就和两数相加一样了。

## 20220305，赎金信

[leetcode链接](https://leetcode-cn.com/problems/4sum-ii/)

*关键词* ：哈希表

这也太简单了……

## 20220306，三数之和

[leetcode链接](https://leetcode-cn.com/problems/3sum/)

*关键词* ：双指针

先排序再利用双指针的做法，把时间复杂度阶数降低一级，空间复杂度只有排序的O(log n)，而且利用排序后可以跳过相同元素的特性，也可以避免去重，所以以后在做到需要去重的题目时，除了用哈希表，也可以考虑先排序再处理。

另外也借助这道题练习了一下快排的写法，还是有很多细节注意不到，这里以自己常用的写法为例列举一些需要注意的点，强化一下记忆：

1. 单次循环方面，循环使用的循环是`while(true)`，然后分别移动左指针和右指针，移动完之后先判断是否满足左指针小于右指针的关系，如果满足的话在进行交换，否则跳出循环。
2. 在移动左右指针时，以左指针为例，`while`循环的判断条件除了`nums[left]<nums[start]`之外，另一个条件要是`left<end`而不是`left<right`，因为`left<right`的判断会在移动完指针，交换数据前再进行判断，如果把这个条件放到`while`循环的条件里会影响`left`和`right`的最终位置。
3. 最后进行完一次遍历后，和`start`位置的元素交换的是`right`位置的元素。

## 20220307，四数之和

[leetcode链接](https://leetcode-cn.com/problems/4sum/)

*关键词* ：双指针

跟上一道题基本一样，都是用双指针法把暴力做法的复杂度降低一阶，需要注意的是剪枝条件与上题略有不同。

## 20220308，用栈实现队列

[leetcode链接](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

*关键词* ：栈

做过的题，用一个输入栈和一个输出栈实现队列，可以把各项操作时间复杂度降到O(1)。

## 20220309，反转字符串

[leetcode链接](https://leetcode-cn.com/problems/reverse-string/)

*关键词* ：无

这算哪门子的双指针……

## 20220310，反转字符串II

[leetcode链接](https://leetcode-cn.com/problems/reverse-string-ii/)

*关键词* ：无

答案是从原来的字符串得到一个字符数组，再在这个字符数组的基础上改，可以简单一些。

## 20220311，替换空格

[leetcode链接](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

*关键词* ：无

普通遍历就可以。
