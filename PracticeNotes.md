# Leetcode刷题笔记

[toc]

## 20211206，除自身以外数组的乘积

[leetcode链接](https://leetcode-cn.com/problems/product-of-array-except-self/)

*关键词* : 双向遍历

做过的题目，从两头各遍历一次，第一次做很难做出来，做过一次后再遇到就容易想到了。

## 20211207，搜索二维矩阵

[leetcode链接](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

*关键词* ：二维数组

也是做过的题，第一次做的时候理解还不深刻，没有意识到自己的解法的问题所在。自己的做法是根据中心点与目标值大小的比较把整个矩阵分成4块，然后可以根据比较结果丢掉一块，分别对剩余三块进行递归，以为这样时间复杂度就是O(log(mn))，实际上不是，见下图：

```text
                                               n
                                                    
                                                    
             n/4                              n/4                               n/4
                  
                                                                                                  log4(mn)层
                  
n/16         n/16        n/16    n/16          n/16         n/16      n/16        n/16      n/16
     
     
     ..................................................................................................
```

最底层总共有3^log4(mn)^ =(mn)^log4(3)^ 个元素，因此根据等比数列求和公式，总的时间复杂度还是O((mn)^log4(3)^)，很接近O(mn)，并不是想的O(log(mn))。而答案的做法则是很巧妙地从右上角开始，每进行一次比较就丢弃掉一行或者一列，时间复杂度达到O(m+n)，代码也很简洁。

## 20211208，完全平方数

[leetcode链接](https://leetcode-cn.com/problems/perfect-squares/)

*关键词* ：动态规划，数学题

动态规划题，一开始还是用的有记忆的递归做的，理论上时间复杂度应该是一样的，但是实际上递归会慢很多，以后遇到这种题就不需要犹豫，直接动态规划就好了。另外答案还给了数学方法的解法，大大降低时间复杂度。但是用到的数学原理实在是太专业了，非数学相关专业一般接触不到的做法，所以也挺无聊的。

## 20211209，寻找重复数

[leetcode链接](https://leetcode-cn.com/problems/find-the-duplicate-number/)

*关键词* ：二分法，位运算，Floyd判圈算法

要满足空间复杂度为O(1)，难度挺大的题。如果时间复杂度为O(nlog(n))，可以采用二分法与位运算的做法，进一步将时间复杂度提高到O(n)，就只有采用Floyd判圈算法。这三种做法思路都非常巧妙，下面分别进行分析。

1. 二分法

    根据数组中比`i`小的元素数量`count[i]`的大小与`i`的大小关系来判断`i`是比要找的数大还是小，从而把`[1, n]`分成两半，对目标所在的一半继续进行递归操作，直到找到目标值。有个细节需要注意，就是用来存储结果的变量`result`的更新的问题，由于`result`肯定是在`count[i] > i`的部分，因此只有进入到这一部分时，才需要将`result`更新为当前的`middle`变量的值，进入另一部分时只需要更新范围，不需要更新结果变量。

2. 位运算

    自己做的时候想过位运算方向的解法，可惜没想明白。这种做法是逐位求出目标值，巧妙点在于对每一位，对比数组`nums`中该位置为`1`的元素的数量，将其与数组`[1, n]`中该位置为`1`的元素数量对比，若前者大，则说明目标值该位置为`1`，否则为`0`，利用这个原理，就能很容易地做出这题。

3. Floyd判圈算法

    最快的做法，时间复杂度达到了O(n)，但我感觉也是没看过答案绝对做不出的方法。这种做法把数组看作一个有向图的`n + 1`条边，分别表示由`i`指向`nums[i]`，`n + 1`个节点共有`n + 1`条边，而且必有一个节点入度为`2`以上，因此该有向图必存在一个圈，且入圈的节点就是入度为`2`的节点，也就是我们要找的重复数，这个问题就变成了寻找环形链表的入环节点的问题，就可以用时间复杂度为O(n)的Floyd判圈算法解决该问题。

## 20211210，最长递增子序列

[leetcode链接](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

*关键词* ：二分法，动态规划，改进动态规划

O(n^2^)时间复杂度的解法不难实现，普通的动态规划就可以，而O(nlog(n))时间复杂度的解法就很困难了。前者选取的状态变量为以元素`nums[i]`结尾的最长递增子序列，而后者则完全换了方法，选取长度为`l`的最长递增子序列的结尾元素作为状态变量，并在遍历的过程中对状态变量数组进行更新，这种情况下的状态变量数组是有序的，因此就可以采用二分查找，把时间复杂度降下来。这种题至少需要大量的积累才有可能能有最优解法的思路，还需努力。

## 20211211，最佳买卖股票时机含冷冻期

[leetcode链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

*关键词* ：动态规划，空间优化动态规划

比较难的动态规划问题。选取的状态变量是能比较容易想到的第`i`天结束后的最大收益，不过困难的是这个状态变量又分成了三种情况，分别是第`i`天结束后持有股票，未持有股票并处于冷冻期和未持有股票而且不处于冷冻期，根据第`i - 1`天这三种情况下的状态就可以推出第`i`天的状态。最后只需要求出最后一天两种不持有股票情况下的最大值就可以得出答案。综合来看状态变量的选取以及转移方程都比较难想，还需要更多积累才能做好这道题。

## 20211212，零钱兑换

[leetcode链接](https://leetcode-cn.com/problems/coin-change/)

*关键词* ：动态规划

基本上是最基础的不能进行空间优化的动态规划了，和前几天做的[完全平方数的题](##20211208，完全平方数)的动态规划解法差不多。

## 20211213，打家劫舍III

[leetcode链接](https://leetcode-cn.com/problems/house-robber-iii/)

*关键词* ：记忆递归，动态规划，空间优化动态规划，深度优先搜索(DFS)

把动态规划搬到了二叉树结构，与普通动态规划区别只是在于将普通数组换成了哈希表。由于对二叉树的深度优先遍历本身就要用到递归栈，因此本题用带记忆的递归也可以做，本质上是一样的，就是动态规划是后序遍历，而记忆递归某种程度上算是先序遍历。不过动态规划可以进行空间优化，由于对于每个节点的分析只需要用到它的两个子节点的结果，因此可以去掉哈希表。

## 20211214，前K个高频元素

[leetcode链接](https://leetcode-cn.com/problems/top-k-frequent-elements/)

*关键词* ：堆，快速排序

可以用大根堆做，也可以用小根堆做，大根堆就是把所有元素放进堆中，然后取出前K个放进数组，这种情况下的时间复杂度是O(nlog(n))，而小根堆则是将容量限制为K，维护前K个出现频率最高的元素，这种情况下的时间复杂度是O(nlog(k))，所以理论上来说小根堆更好一些。另一种做法是利用快排的原理，每次确定一个元素的位置，直到确定的元素位置恰好为K时，即可确定前K个高频元素，这种解法理论上的时间复杂度可以降低到O(n)。

## 20211215，字符串解码

[leetcode链接](https://leetcode-cn.com/problems/decode-string/)

*关键词* ：栈，递归

辅助栈的做法和递归的做法差不多。这种题说难也不难，但是麻烦是真麻烦，要把代码写得简洁更麻烦，不知道笔试面试喜欢不喜欢考这种题。

## 20211216，除法求值（待解决）

[leetcode链接](https://leetcode-cn.com/problems/evaluate-division/)

*关键词* ：加权并查集

很难啊，先留一留，后面慢慢看。

## 20211217，根据身高重建队列

[leetcode链接](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

*关键词* ：排序

想法不算很难的一道题。有个细节需要注意，就是排序的时候可以优先通过身高排序，然后根据第二项也就是身前有多少人进行逆序排序，这样就可以避免另外处理身高相同的情况，这个想法很值得学习。另外让我不太明白的一点在于从低到高排序然后通过数`null`来插入数组的做法为什么会比从高到低排序然后插入列表然后转化为数组的做法慢这么多，能想到的可能的原因在于第一种方法耗费的时间大约是n^2^，而第二种方法耗费的时间大约是n^2^/2，或者还是说Java的ArrayList的插入有优化？不理解。
