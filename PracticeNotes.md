# Leetcode刷题笔记

[toc]

## 20211206，除自身以外数组的乘积

[leetcode链接](https://leetcode-cn.com/problems/product-of-array-except-self/)

*关键词* : 双向遍历

做过的题目，从两头各遍历一次，第一次做很难做出来，做过一次后再遇到就容易想到了。

## 20211207，搜索二维矩阵

[leetcode链接](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

*关键词* ：二维数组

也是做过的题，第一次做的时候理解还不深刻，没有意识到自己的解法的问题所在。自己的做法是根据中心点与目标值大小的比较把整个矩阵分成4块，然后可以根据比较结果丢掉一块，分别对剩余三块进行递归，以为这样时间复杂度就是O(log(mn))，实际上不是，见下图：

```text
                                               n
                                                    
                                                    
             n/4                              n/4                               n/4
                  
                                                                                                  log4(mn)层
                  
n/16         n/16        n/16    n/16          n/16         n/16      n/16        n/16      n/16
     
     
     ..................................................................................................
```

最底层总共有3^log4(mn)^ =(mn)^log4(3)^ 个元素，因此根据等比数列求和公式，总的时间复杂度还是O((mn)^log4(3)^)，很接近O(mn)，并不是想的O(log(mn))。而答案的做法则是很巧妙地从右上角开始，每进行一次比较就丢弃掉一行或者一列，时间复杂度达到O(m+n)，代码也很简洁。

## 20211208，完全平方数

[leetcode链接](https://leetcode-cn.com/problems/perfect-squares/)

*关键词* ：动态规划，数学题

动态规划题，一开始还是用的有记忆的递归做的，理论上时间复杂度应该是一样的，但是实际上递归会慢很多，以后遇到这种题就不需要犹豫，直接动态规划就好了。另外答案还给了数学方法的解法，大大降低时间复杂度。但是用到的数学原理实在是太专业了，非数学相关专业一般接触不到的做法，所以也挺无聊的。

## 20211209，寻找重复数

[leetcode链接](https://leetcode-cn.com/problems/find-the-duplicate-number/)

*关键词* ：二分法，位运算，Floyd判圈算法

要满足空间复杂度为O(1)，难度挺大的题。如果时间复杂度为O(nlog(n))，可以采用二分法与位运算的做法，进一步将时间复杂度提高到O(n)，就只有采用Floyd判圈算法。这三种做法思路都非常巧妙，下面分别进行分析。

1. 二分法

    根据数组中比`i`小的元素数量`count[i]`的大小与`i`的大小关系来判断`i`是比要找的数大还是小，从而把`[1, n]`分成两半，对目标所在的一半继续进行递归操作，直到找到目标值。有个细节需要注意，就是用来存储结果的变量`result`的更新的问题，由于`result`肯定是在`count[i] > i`的部分，因此只有进入到这一部分时，才需要将`result`更新为当前的`middle`变量的值，进入另一部分时只需要更新范围，不需要更新结果变量。

2. 位运算

    自己做的时候想过位运算方向的解法，可惜没想明白。这种做法是逐位求出目标值，巧妙点在于对每一位，对比数组`nums`中该位置为`1`的元素的数量，将其与数组`[1, n]`中该位置为`1`的元素数量对比，若前者大，则说明目标值该位置为`1`，否则为`0`，利用这个原理，就能很容易地做出这题。

3. Floyd判圈算法

    最快的做法，时间复杂度达到了O(n)，但我感觉也是没看过答案绝对做不出的方法。这种做法把数组看作一个有向图的`n + 1`条边，分别表示由`i`指向`nums[i]`，`n + 1`个节点共有`n + 1`条边，而且必有一个节点入度为`2`以上，因此该有向图必存在一个圈，且入圈的节点就是入度为`2`的节点，也就是我们要找的重复数，这个问题就变成了寻找环形链表的入环节点的问题，就可以用时间复杂度为O(n)的Floyd判圈算法解决该问题。
